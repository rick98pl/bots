using System;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Text.Json;
using System.Collections.Concurrent;

class Program
{
    [DllImport("kernel32.dll")]
    static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int processId);

    [DllImport("user32.dll", SetLastError = true)]
    static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);

    [DllImport("kernel32.dll")]
    static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] buffer, int size, out int lpNumberOfBytesRead);

    [DllImport("user32.dll")]
    static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);

    [DllImport("user32.dll")]
    static extern int GetWindowText(IntPtr hWnd, System.Text.StringBuilder lpString, int nMaxCount);

    [DllImport("user32.dll")]
    static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

    delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);

    const int PROCESS_WM_READ = 0x0010;
    const uint WM_KEYDOWN = 0x0100;
    const uint WM_KEYUP = 0x0101;

    const int VK_LEFT = 0x25;
    const int VK_UP = 0x26;
    const int VK_RIGHT = 0x27;
    const int VK_DOWN = 0x28;

    static class Keys
    {
        public static readonly Dictionary<string, int> KeyMap = new Dictionary<string, int>
        {
            { "F1", 0x70 }, { "F2", 0x71 }, { "F3", 0x72 }, { "F4", 0x73 },
            { "F5", 0x74 }, { "F6", 0x75 }, { "F7", 0x76 }, { "F8", 0x77 },
            { "F9", 0x78 }, { "F10", 0x79 }, { "F11", 0x7A }, { "F12", 0x7B }
        };

        public static int GetKeyCode(string keyName) => KeyMap.ContainsKey(keyName) ? KeyMap[keyName] : -1;
    }

    const int DEFAULT_HP_THRESHOLD = 50;
    const int DEFAULT_MANA_THRESHOLD = 70;
    const string DEFAULT_HP_KEY_NAME = "F1";
    const string DEFAULT_MANA_KEY_NAME = "F2";

    static int DEFAULT_HP_KEY => Keys.GetKeyCode(DEFAULT_HP_KEY_NAME);
    static int DEFAULT_MANA_KEY => Keys.GetKeyCode(DEFAULT_MANA_KEY_NAME);

    static IntPtr targetWindow = IntPtr.Zero;
    static DateTime lastHpActionTime = DateTime.MinValue;
    static DateTime lastManaActionTime = DateTime.MinValue;
    static Random random = new Random();

    static IntPtr xAddressOffset = (IntPtr)0x009435FC;
    static IntPtr yAddressOffset = (IntPtr)0x00943600;
    static IntPtr zAddressOffset = (IntPtr)0x00943604;
    static IntPtr targetIdOffset = (IntPtr)0x009432D4;
    static IntPtr followOffset = (IntPtr)0x00943380;

    // Memory values (updated by background thread)
    static double curHP = 0, maxHP = 1, curMana = 0, maxMana = 1;
    static int posX = 0, posY = 0, posZ = 0, targetId = 0, follow = 0;
    static bool memoryReadActive = false;
    static bool programRunning = true;

    // Thread controls and flags
    static bool autoPotionActive = false;
    static bool isRecording = false;
    static bool isPlaying = false;
    static bool shouldRestartMemoryThread = false;

    // Thread communication
    static ConcurrentDictionary<string, bool> threadFlags = new ConcurrentDictionary<string, bool>();
    static object memoryLock = new object();

    static List<Coordinate> recordedCoords = new List<Coordinate>();
    static string cordsFilePath = "cords.json";
    static CoordinateData loadedCoords = null;
    static Process selectedProcess = null;
    static IntPtr processHandle = IntPtr.Zero;
    static IntPtr moduleBase = IntPtr.Zero;

    struct Variable
    {
        public string Name;
        public IntPtr BaseAddress;
        public List<int> Offsets;
        public string Type;
    }

    class Coordinate
    {
        public int X { get; set; }
        public int Y { get; set; }
        public int Z { get; set; }
    }

    class CoordinateData
    {
        public List<Coordinate> cords { get; set; } = new List<Coordinate>();
    }

    // Path playback status tracking
    static int currentCoordIndex = -1;
    static int totalCoords = 0;
    static Coordinate currentTarget = null;
    static bool debug = true;
    static int debugTime = 2;

    static void Main()
    {
        Console.WriteLine($"Default HP Key: {DEFAULT_HP_KEY_NAME}");
        Console.WriteLine($"Default Mana Key: {DEFAULT_MANA_KEY_NAME}");

        // Initialize thread flags
        threadFlags["recording"] = false;
        threadFlags["playing"] = false;
        threadFlags["autopot"] = false;

        if (!File.Exists(cordsFilePath))
        {
            SaveCoordinates(); // Create empty cords.json if missing
        }

        string processName = "RealeraDX";

        while (programRunning)
        {
            while (selectedProcess == null)
            {
                var processes = Process.GetProcesses()
                                .Where(p => p.ProcessName == processName)
                                .ToArray();

                if (processes.Length == 0)
                {
                    Console.WriteLine($"Process '{processName}' not found.");
                    Thread.Sleep(500);
                    continue;
                }
                else if (processes.Length == 1)
                {
                    selectedProcess = processes[0];
                    Console.WriteLine($"One process found: {selectedProcess.ProcessName} (ID: {selectedProcess.Id})");
                }
                else
                {
                    Console.WriteLine($"Multiple processes found with name '{processName}':");
                    for (int i = 0; i < processes.Length; i++)
                    {
                        Console.WriteLine($"{i + 1}: ID={processes[i].Id}, Name={processes[i].ProcessName}, StartTime={(processes[i].StartTime)}");
                    }

                    Console.WriteLine("Enter the number of the process you want to select (1-9):");
                    string input = Console.ReadLine();

                    if (int.TryParse(input, out int choice) &&
                        choice >= 1 && choice <= processes.Length)
                    {
                        selectedProcess = processes[choice - 1];
                        Console.WriteLine($"Selected process: {selectedProcess.ProcessName} (ID: {selectedProcess.Id})");
                    }
                    else
                    {
                        Console.WriteLine("Invalid selection. Please try again.");
                    }
                }
            }

            FindRealeraWindow(selectedProcess);
            processHandle = OpenProcess(PROCESS_WM_READ, false, selectedProcess.Id);
            moduleBase = selectedProcess.MainModule.BaseAddress;

            // Start worker threads
            StartWorkerThreads();

            // Main loop for UI updates and handling user input
            while (memoryReadActive && !shouldRestartMemoryThread)
            {
                // Display stats periodically
               // DisplayStats();

                // Handle user input
                if (Console.KeyAvailable)
                {
                    var key = Console.ReadKey(true).Key;
                    HandleUserInput(key);
                }

                Thread.Sleep(250); // Refresh UI at a reasonable rate
            }

            if (shouldRestartMemoryThread)
            {
                shouldRestartMemoryThread = false;
                StopWorkerThreads();
                selectedProcess = null; // Reset to find process again
            }
        }
    }

    static void StartWorkerThreads()
    {
        // Reset flags
        memoryReadActive = true;

        // Start memory reading thread
        Thread memoryThread = new Thread(MemoryReadingThread);
        memoryThread.IsBackground = true;
        memoryThread.Name = "MemoryReader";
        memoryThread.Start();

        // Start auto-potion thread
        Thread autoPotionThread = new Thread(AutoPotionThread);
        autoPotionThread.IsBackground = true;
        autoPotionThread.Name = "AutoPotion";
        autoPotionThread.Start();

        Console.WriteLine("Worker threads started successfully");
    }

    static void StopWorkerThreads()
    {
        memoryReadActive = false;
        threadFlags["recording"] = false;
        threadFlags["playing"] = false;

        Console.WriteLine("Worker threads stopping...");
        Thread.Sleep(1000); // Give threads time to gracefully exit
    }

    static List<Variable> variables = new List<Variable>
        {
            new Variable { Name = "Current Mana", BaseAddress = (IntPtr)0x009432D0, Offsets = new List<int>{ 1240 }, Type = "Double" },
            new Variable { Name = "Current HP", BaseAddress = (IntPtr)0x009432D0, Offsets = new List<int>{ 1184 }, Type = "Double" },
            new Variable { Name = "Max Mana", BaseAddress = (IntPtr)0x009432D0, Offsets = new List<int>{ 1248 }, Type = "Double" },
            new Variable { Name = "Max HP", BaseAddress = (IntPtr)0x009432D0, Offsets = new List<int>{ 1192 }, Type = "Double" }
        };

    static void MemoryReadingThread()
    {
        Console.WriteLine("Memory reading thread started");

        while (memoryReadActive)
        {
            try
            {
                // Check if process is still running
                if (selectedProcess.HasExited)
                {
                    shouldRestartMemoryThread = true;
                    break;
                }

                // Read memory values
                foreach (var variable in variables)
                {
                    try
                    {
                        IntPtr address = IntPtr.Add(moduleBase, (int)variable.BaseAddress);
                        byte[] buffer;

                        if (variable.Offsets.Count > 0)
                        {
                            buffer = new byte[4];
                            if (!ReadProcessMemory(processHandle, address, buffer, buffer.Length, out _)) continue;
                            address = (IntPtr)BitConverter.ToInt32(buffer, 0);
                            address = IntPtr.Add(address, variable.Offsets[0]);
                        }

                        buffer = variable.Type == "Double" ? new byte[8] : new byte[4];
                        if (!ReadProcessMemory(processHandle, address, buffer, buffer.Length, out _)) continue;

                        double value = variable.Type == "Double"
                            ? BitConverter.ToDouble(buffer, 0)
                            : BitConverter.ToInt32(buffer, 0);

                        lock (memoryLock)
                        {
                            if (variable.Name.Contains("HP") && !variable.Name.Contains("Max")) curHP = value;
                            if (variable.Name.Contains("Mana") && !variable.Name.Contains("Max")) curMana = value;
                            if (variable.Name.Contains("Max HP")) maxHP = value;
                            if (variable.Name.Contains("Max Mana")) maxMana = value;
                        }
                    }
                    catch { }
                }

                // Read position values
                lock (memoryLock)
                {
                    posX = ReadInt32(processHandle, moduleBase, xAddressOffset);
                    posY = ReadInt32(processHandle, moduleBase, yAddressOffset);
                    posZ = ReadInt32(processHandle, moduleBase, zAddressOffset);
                    targetId = ReadInt32(processHandle, moduleBase, targetIdOffset);
                    follow = ReadInt32(processHandle, moduleBase, followOffset);

                    // Record coordinate if recording is active
                    if (threadFlags["recording"])
                    {
                        RecordCoordinate(posX, posY, posZ);
                    }
                }

                Thread.Sleep(1); // Read memory at high frequency
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Memory reading error: {ex.Message}");
                shouldRestartMemoryThread = true;
                break;
            }
        }
        Console.WriteLine("Memory reading thread exited");
    }

    static void AutoPotionThread()
    {
        Console.WriteLine("Auto-potion thread started");

        while (memoryReadActive)
        {
            try
            {
                if (threadFlags["autopot"] && targetWindow != IntPtr.Zero)
                {
                    var now = DateTime.Now;
                    var thresholdms = 1000;
                    double hpPercent, manaPercent;

                    lock (memoryLock)
                    {
                        hpPercent = (curHP / maxHP) * 100;
                        manaPercent = (curMana / maxMana) * 100;
                    }

                    if (hpPercent == 0)
                    {
                        Thread.Sleep(200);
                        continue;
                    }

                    if (hpPercent <= DEFAULT_HP_THRESHOLD)
                    {
                        if ((now - lastHpActionTime).TotalMilliseconds >= thresholdms)
                        {
                            Console.WriteLine($"⚠ HP below threshold ({DEFAULT_HP_THRESHOLD}%), current HP: {curHP}/{maxHP} ({hpPercent:F1}%), sending {DEFAULT_HP_KEY_NAME}");
                            SendKeyPress(DEFAULT_HP_KEY);
                            lastHpActionTime = now.AddMilliseconds(random.Next(0, 100));
                        }
                    }

                    if (manaPercent <= DEFAULT_MANA_THRESHOLD)
                    {
                        if ((now - lastManaActionTime).TotalMilliseconds >= thresholdms)
                        {
                            Console.WriteLine($"⚠ Mana below threshold ({DEFAULT_MANA_THRESHOLD}%), sending {DEFAULT_MANA_KEY_NAME}");
                            SendKeyPress(DEFAULT_MANA_KEY);
                            lastManaActionTime = now.AddMilliseconds(random.Next(0, 100));
                        }
                    }
                }

                Thread.Sleep(100); // Check potions at moderate frequency
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Auto-potion error: {ex.Message}");
                Thread.Sleep(1000);
            }
        }
        Console.WriteLine("Auto-potion thread exited");
    }

    static void DisplayStats()
    {
        Console.Clear();
        double hpPercent;
        double manaPercent;
        int currentX, currentY, currentZ;

        lock (memoryLock)
        {
            hpPercent = (curHP / maxHP) * 100;
            manaPercent = (curMana / maxMana) * 100;
            currentX = posX;
            currentY = posY;
            currentZ = posZ;
        }

        Console.WriteLine("RealeraDX - Live Stats:\n");
        Console.WriteLine("{0,-20} {1,15}", "Metric", "Value");
        Console.WriteLine(new string('-', 40));
        Console.WriteLine("{0,-20} {1,15:F0}", "Current HP", curHP);
        Console.WriteLine("{0,-20} {1,15:F0}", "Max HP", maxHP);
        Console.WriteLine("{0,-20} {1,15:F1}%", "HP %", hpPercent);
        Console.WriteLine("{0,-20} {1,15:F0}", "Current Mana", curMana);
        Console.WriteLine("{0,-20} {1,15:F0}", "Max Mana", maxMana);
        Console.WriteLine("{0,-20} {1,15:F1}%", "Mana %", manaPercent);
        Console.WriteLine("{0,-20} {1,15:F0}", "targetId", targetId);
        Console.WriteLine("{0,-20} {1,15:F0}", "follow", follow);
        Console.WriteLine(new string('-', 40));
        Console.WriteLine($"Position: X={currentX}, Y={currentY}, Z={currentZ}");

        if (threadFlags["recording"])
        {
            Console.WriteLine("🔴 Recording coordinates...");
            Console.WriteLine($"Coordinates recorded: {recordedCoords.Count}");
        }

        if (threadFlags["playing"] && currentTarget != null)
        {
            Console.WriteLine("\n▶️ PLAYING PATH:");
            Console.WriteLine(new string('-', 40));
            Console.WriteLine($"Progress: {currentCoordIndex + 1}/{totalCoords} ({(((float)(currentCoordIndex + 1) / totalCoords) * 100):F1}%)");
            Console.WriteLine($"Current: X={currentX}, Y={currentY}, Z={currentZ}");
            Console.WriteLine($"Target:  X={currentTarget.X}, Y={currentTarget.Y}, Z={currentTarget.Z}");

            int distanceX = Math.Abs(currentTarget.X - currentX);
            int distanceY = Math.Abs(currentTarget.Y - currentY);
            Console.WriteLine($"Distance: {distanceX + distanceY} steps");

            // Draw a simple progress bar
            int barLength = 20;
            int progress = (int)Math.Round((double)(currentCoordIndex + 1) / totalCoords * barLength);
            Console.Write("[");
            for (int i = 0; i < barLength; i++)
            {
                Console.Write(i < progress ? "█" : " ");
            }
            Console.WriteLine($"] {(((float)(currentCoordIndex + 1) / totalCoords) * 100):F1}%");
        }

        Console.WriteLine("\nActive Features:");
        Console.WriteLine($"Auto-Potions: {(threadFlags["autopot"] ? "✅ ON" : "❌ OFF")} (A)");
        Console.WriteLine($"Recording: {(threadFlags["recording"] ? "✅ ON" : "❌ OFF")} (R)");
        Console.WriteLine($"Playback: {(threadFlags["playing"] ? "✅ ON" : "❌ OFF")} (P)");

        Console.WriteLine("\nCommands:");
        Console.WriteLine("R - Start/Stop Recording");
        Console.WriteLine("P - Start/Stop Path Playback");
        Console.WriteLine("A - Toggle Auto-Potions");
        Console.WriteLine("Q - Quit");
    }

    static void HandleUserInput(ConsoleKey key)
    {
        switch (key)
        {
            case ConsoleKey.R:
                // Toggle recording
                if (!threadFlags["recording"] && !threadFlags["playing"])
                {
                    Console.Write("Start recording coordinates? (y/n): ");
                    string confirm = Console.ReadLine();
                    if (confirm.ToLower() == "y")
                    {
                        threadFlags["recording"] = true;
                        recordedCoords.Clear();
                        Console.WriteLine("Started recording coordinates...");
                    }
                }
                else if (threadFlags["recording"])
                {
                    threadFlags["recording"] = false;
                    SaveCoordinates();
                    Console.WriteLine("Stopped recording and saved coordinates.");
                }
                break;

            case ConsoleKey.P:
                // Toggle path playback
                if (!threadFlags["playing"] && !threadFlags["recording"])
                {
                    if (File.Exists(cordsFilePath))
                    {
                        threadFlags["playing"] = true;
                        StartPathPlayback();
                    }
                    else
                    {
                        Console.WriteLine("cords.json not found!");
                        Thread.Sleep(1000);
                    }
                }
                else if (threadFlags["playing"])
                {
                    // Stop playback
                    threadFlags["playing"] = false;
                    Console.WriteLine("Path playback stopped.");
                }
                break;

            case ConsoleKey.A:
                // Toggle auto-potions
                threadFlags["autopot"] = !threadFlags["autopot"];
                Console.WriteLine($"Auto-potions {(threadFlags["autopot"] ? "enabled" : "disabled")}");
                break;

            case ConsoleKey.Q:
                programRunning = false;
                memoryReadActive = false;
                threadFlags["recording"] = false;
                threadFlags["playing"] = false;
                threadFlags["autopot"] = false;
                break;
        }
    }

    static void StartPathPlayback()
    {
        Thread playThread = new Thread(() =>
        {
            try
            {
                PlayCoordinates();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Path playback error: {ex.Message}");
            }
            finally
            {
                // Make sure to reset flag if thread exits for any reason
                threadFlags["playing"] = false;
            }
        });
        playThread.IsBackground = true;
        playThread.Name = "PathPlayer";
        playThread.Start();
    }

    static int ReadInt32(IntPtr handle, IntPtr moduleBase, IntPtr offset)
    {
        IntPtr address = IntPtr.Add(moduleBase, (int)offset);
        byte[] buffer = new byte[4];
        if (ReadProcessMemory(handle, address, buffer, buffer.Length, out _))
            return BitConverter.ToInt32(buffer, 0);
        return 0;
    }

    static void SendKeyPress(int key)
    {
        PostMessage(targetWindow, WM_KEYDOWN, (IntPtr)key, IntPtr.Zero);
        Thread.Sleep(random.Next(10, 70));
        PostMessage(targetWindow, WM_KEYUP, (IntPtr)key, IntPtr.Zero);
    }

    static void FindRealeraWindow(Process process)
    {
        EnumWindows((hWnd, lParam) =>
        {
            uint windowProcessId;
            GetWindowThreadProcessId(hWnd, out windowProcessId);

            if (windowProcessId == (uint)process.Id)
            {
                StringBuilder sb = new StringBuilder(256);
                GetWindowText(hWnd, sb, sb.Capacity);

                if (sb.ToString().Contains("Realera 8.0"))
                {
                    targetWindow = hWnd;
                    return false;
                }
            }
            return true;
        }, IntPtr.Zero);
    }

    static void SaveCoordinates()
    {
        CoordinateData data = new CoordinateData { cords = recordedCoords };
        string json = JsonSerializer.Serialize(data, new JsonSerializerOptions { WriteIndented = true });
        File.WriteAllText(cordsFilePath, json);
    }

    static void RecordCoordinate(int x, int y, int z)
    {
        if (recordedCoords.Count == 0 || recordedCoords.Last().X != x || recordedCoords.Last().Y != y || recordedCoords.Last().Z != z)
        {
            recordedCoords.Add(new Coordinate { X = x, Y = y, Z = z });
        }
    }

    static Coordinate FindClosestCoordinate(int x, int y, int z, List<Coordinate> coords)
    {
        return coords.OrderBy(c => Math.Abs(c.X - x) + Math.Abs(c.Y - y) + Math.Abs(c.Z - z)).First();
    }









    static void PlayCoordinates()
    {
        Console.WriteLine("Path playback starting...");

        // Load coordinates from file
        string json = File.ReadAllText(cordsFilePath);
        loadedCoords = JsonSerializer.Deserialize<CoordinateData>(json);

        if (loadedCoords == null || loadedCoords.cords.Count == 0)
        {
            Console.WriteLine("No coordinates found in cords.json!");
            threadFlags["playing"] = false;
            return;
        }

        // Initialize variables for path playback
        List<Coordinate> waypoints = loadedCoords.cords;
        totalCoords = waypoints.Count;
        HashSet<int> blacklistedTargets = new HashSet<int>();
        bool isReversed = false;

        Console.WriteLine($"Loaded {totalCoords} coordinates from cords.json");

        // Always find closest waypoint on startup or resuming
        int currentX, currentY, currentZ;
        lock (memoryLock)
        {
            currentX = posX;
            currentY = posY;
            currentZ = posZ;
        }

        // Find the closest waypoint to start with
        currentCoordIndex = FindClosestWaypointIndex(waypoints, currentX, currentY, currentZ);
        if (debug) Console.WriteLine($"[DEBUG] Starting at closest waypoint: index {currentCoordIndex}");

        while (threadFlags["playing"])
        {
            try
            {
                // Get current position
                int currentTargetId;

                lock (memoryLock)
                {
                    currentX = posX;
                    currentY = posY;
                    currentZ = posZ;
                    currentTargetId = targetId;
                }

                // If we have a target, handle combat
                if (currentTargetId != 0)
                {
                    // If target is blacklisted, press ESC to cancel target and continue
                    if (blacklistedTargets.Contains(currentTargetId))
                    {
                        if (debug) Console.WriteLine($"[DEBUG] Skipping blacklisted target: {currentTargetId}");
                        SendKeyPress(VK_ESCAPE); // Press ESC to cancel targeting
                        Thread.Sleep(100);
                        continue;
                    }

                    // Combat in progress, wait for it to resolve
                    DateTime combatStartTime = DateTime.Now;
                    bool combatTimeout = false;
                    int lastSeenTargetId = currentTargetId;

                    // Wait for combat to resolve (up to 30 seconds)
                    while (currentTargetId != 0 && !combatTimeout)
                    {
                        // Check for timeout (30 seconds)
                        if ((DateTime.Now - combatStartTime).TotalSeconds > 30)
                        {
                            combatTimeout = true;
                            if (debug) Console.WriteLine($"[DEBUG] Combat timeout after 30 seconds, blacklisting target: {currentTargetId}");

                            // Blacklist this target
                            blacklistedTargets.Add(currentTargetId);

                            // Press ESC to cancel targeting
                            SendKeyPress(VK_ESCAPE);
                        }

                        Thread.Sleep(100);

                        lock (memoryLock)
                        {
                            currentTargetId = targetId;
                        }

                        // Check if target changed during combat (new creature)
                        if (currentTargetId != 0 && currentTargetId != lastSeenTargetId)
                        {
                            if (debug) Console.WriteLine($"[DEBUG] Target changed during combat from {lastSeenTargetId} to {currentTargetId}");
                            lastSeenTargetId = currentTargetId;
                            combatStartTime = DateTime.Now; // Reset timeout for new target
                        }
                    }

                    // Combat has ended, loot the corpse
                    if (!combatTimeout)
                    {
                        if (debug) Console.WriteLine("[DEBUG] Combat ended, searching for loot");
                        ClickAroundCharacter(targetWindow);
                        Thread.Sleep(1); // Give time for loot to be picked up
                    }

                    // After combat ends, find closest waypoint to resume path
                    lock (memoryLock)
                    {
                        currentX = posX;
                        currentY = posY;
                        currentZ = posZ;
                    }

                    // Find the closest waypoint to resume from
                    currentCoordIndex = FindClosestWaypointIndex(waypoints, currentX, currentY, currentZ);
                    if (debug) Console.WriteLine($"[DEBUG] Resuming from closest waypoint: index {currentCoordIndex}");

                    continue; // Go back to main loop to check for new targets or movement
                }

                // No target, try pressing F6 to find one
                if (debug) Console.WriteLine("[DEBUG] No target, pressing F6 to search");
                SendKeyPress(VK_F6);

                // Wait for results of F6 (target search)
                Thread.Sleep(1);

                lock (memoryLock)
                {
                    currentTargetId = targetId;
                }

                // If we got a target, continue to combat loop
                if (currentTargetId != 0)
                {
                    if (debug) Console.WriteLine($"[DEBUG] Found target: {currentTargetId}");
                    continue;
                }

                // No target found, proceed with movement
                if (debug) Console.WriteLine("[DEBUG] No target found, proceeding with movement");

                // Wait a bit before moving (as requested)
                Thread.Sleep(1);

                // Check if we need to find the closest waypoint again (in case we're off track)
                bool potentiallyOffTrack = false;

                // Check if current position is far from the expected path
                if (currentCoordIndex < waypoints.Count)
                {
                    var expectedWaypoint = waypoints[currentCoordIndex];
                    int distanceToExpected = Math.Abs(expectedWaypoint.X - currentX) +
                                            Math.Abs(expectedWaypoint.Y - currentY);

                    // If we're more than 3 tiles away from where we should be, consider off track
                    if (distanceToExpected > 3)
                    {
                        potentiallyOffTrack = true;
                    }
                }

                // Re-find closest waypoint if potentially off track
                if (potentiallyOffTrack)
                {
                    int newIndex = FindClosestWaypointIndex(waypoints, currentX, currentY, currentZ);
                    if (newIndex != currentCoordIndex)
                    {
                        if (debug) Console.WriteLine($"[DEBUG] Off track detected, adjusting to waypoint: {newIndex}");
                        currentCoordIndex = newIndex;
                    }
                }

                // Find best candidate for next waypoint (at least 5 sqms away if possible)
                Coordinate nextWaypoint = FindNextWaypoint(waypoints, currentX, currentY, currentZ,
                                                         currentCoordIndex, isReversed);
                currentTarget = nextWaypoint;

                if (debug) Console.WriteLine($"[DEBUG] Moving to waypoint: X={nextWaypoint.X}, Y={nextWaypoint.Y}, Z={nextWaypoint.Z}");

                // Calculate distance to target
                int distanceX = Math.Abs(nextWaypoint.X - currentX);
                int distanceY = Math.Abs(nextWaypoint.Y - currentY);
                int totalDistance = distanceX + distanceY;

                // Check if we need to reverse direction
                if (totalDistance > 7 && !isReversed)
                {
                    if (debug) Console.WriteLine("[DEBUG] Distance too far, reversing waypoint list");
                    isReversed = true;
                    waypoints.Reverse();

                    // Find closest waypoint in reversed list
                    currentCoordIndex = FindClosestWaypointIndex(waypoints, currentX, currentY, currentZ);

                    // Recalculate next waypoint
                    nextWaypoint = FindNextWaypoint(waypoints, currentX, currentY, currentZ,
                                                  currentCoordIndex, isReversed);
                    currentTarget = nextWaypoint;

                    // Recalculate distance
                    distanceX = Math.Abs(nextWaypoint.X - currentX);
                    distanceY = Math.Abs(nextWaypoint.Y - currentY);
                    totalDistance = distanceX + distanceY;
                }

                // Check if waypoint is within reachable distance
                if (totalDistance <= 7)
                {
                    // Use ClickWaypoint to move to the target with a pixel size of 32
                    if (debug) Console.WriteLine($"[DEBUG] Clicking waypoint: X={nextWaypoint.X}, Y={nextWaypoint.Y}, Z={nextWaypoint.Z}");
                    bool clickSuccess = ClickWaypoint(nextWaypoint, 32);

                    if (!clickSuccess)
                    {
                        if (debug) Console.WriteLine("[DEBUG] Click failed, trying again with different pixel size");
                        // Try with a different pixel size as fallback
                        clickSuccess = ClickWaypoint(nextWaypoint, 36);
                    }

                    // Wait for movement to complete
                    if (clickSuccess)
                    {
                        // Check for follow status (if follow == 1 we're still moving)
                        int followStatus;
                        lock (memoryLock)
                        {
                            followStatus = follow;
                        }

                        // Wait for movement to complete if follow is active
                        DateTime moveStart = DateTime.Now;
                        while (followStatus == 1 &&
                               (DateTime.Now - moveStart).TotalSeconds < 5 && // Max 5 seconds wait
                               threadFlags["playing"])
                        {
                            Thread.Sleep(100);
                            lock (memoryLock)
                            {
                                followStatus = follow;
                                currentX = posX;
                                currentY = posY;
                                currentTargetId = targetId;
                            }

                            // Check for combat interrupt
                            if (currentTargetId != 0)
                            {
                                if (debug) Console.WriteLine("[DEBUG] Target found while waiting for movement, switching to combat");
                                break;
                            }
                        }

                        // Press F6 after movement completes to check for targets
                        if (currentTargetId == 0)
                        {
                            SendKeyPress(VK_F6);
                            Thread.Sleep(200);
                            lock (memoryLock)
                            {
                                currentTargetId = targetId;
                            }

                            if (currentTargetId != 0)
                            {
                                if (debug) Console.WriteLine("[DEBUG] Target found after movement, switching to combat");
                                continue;
                            }
                        }
                    }
                }
                else
                {
                    if (debug) Console.WriteLine($"[DEBUG] Waypoint too far ({totalDistance} steps), cannot reach");
                    // Skip this waypoint and try the next one
                }

                // Update position for next iteration
                lock (memoryLock)
                {
                    currentX = posX;
                    currentY = posY;
                }

                // Check if we reached the waypoint (or close enough)
                int finalDistanceX = Math.Abs(nextWaypoint.X - currentX);
                int finalDistanceY = Math.Abs(nextWaypoint.Y - currentY);
                int finalTotalDistance = finalDistanceX + finalDistanceY;

                // Consider waypoint reached if within 2 sqms (to account for obstacles)
                if (finalTotalDistance <= 2)
                {
                    if (debug) Console.WriteLine("[DEBUG] Waypoint reached");

                    // Update current index based on direction
                    if (isReversed)
                    {
                        currentCoordIndex--;
                        if (currentCoordIndex < 0)
                        {
                            // Reached the beginning, reverse again
                            waypoints.Reverse();
                            isReversed = false;
                            currentCoordIndex = 1; // Start at second waypoint
                        }
                    }
                    else
                    {
                        currentCoordIndex++;
                        if (currentCoordIndex >= waypoints.Count)
                        {
                            // Reached the end, reverse
                            waypoints.Reverse();
                            isReversed = true;
                            currentCoordIndex = 1; // Start at second waypoint
                        }
                    }
                }
                else
                {
                    // If we didn't reach the destination after movement, check if we're off track
                    if (debug) Console.WriteLine($"[DEBUG] Could not reach waypoint, distance: {finalTotalDistance}");

                    // Try to find closest waypoint for next iteration
                    int newIndex = FindClosestWaypointIndex(waypoints, currentX, currentY, currentZ);
                    if (newIndex != currentCoordIndex)
                    {
                        if (debug) Console.WriteLine($"[DEBUG] Adjusting to closest waypoint: {newIndex}");
                        currentCoordIndex = newIndex;
                    }
                }

                Thread.Sleep(100); // Slow down for debugging if needed
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in path playback: {ex.Message}");
                Thread.Sleep(1000);
            }
        }

        Console.WriteLine("Path playback ended");
    }

    // Helper function to find the index of the closest waypoint
    static int FindClosestWaypointIndex(List<Coordinate> waypoints, int currentX, int currentY, int currentZ)
    {
        int closestIndex = 0;
        int minDistance = int.MaxValue;

        for (int i = 0; i < waypoints.Count; i++)
        {
            var waypoint = waypoints[i];
            int distance = Math.Abs(waypoint.X - currentX) + Math.Abs(waypoint.Y - currentY);

            if (distance < minDistance)
            {
                minDistance = distance;
                closestIndex = i;
            }
        }

        return closestIndex;
    }

    // Helper function to find the best next waypoint
    static Coordinate FindNextWaypoint(List<Coordinate> waypoints, int currentX, int currentY, int currentZ,
                                      int currentIndex, bool isReversed)
    {
        // Try to find waypoint at least 5 sqms away
        int minDistance = 5;
        int maxSearchRange = 10; // Look at most 10 waypoints ahead
        int targetIndex = currentIndex;

        if (!isReversed)
        {
            // Forward search
            for (int i = currentIndex; i < Math.Min(currentIndex + maxSearchRange, waypoints.Count); i++)
            {
                var waypoint = waypoints[i];
                int distance = Math.Abs(waypoint.X - currentX) + Math.Abs(waypoint.Y - currentY);

                if (distance >= minDistance)
                {
                    targetIndex = i;
                    break;
                }

                // If we're getting close to the end, just use the last waypoint
                if (i == waypoints.Count - 1)
                {
                    targetIndex = i;
                }
            }
        }
        else
        {
            // Backward search
            for (int i = currentIndex; i >= Math.Max(currentIndex - maxSearchRange, 0); i--)
            {
                var waypoint = waypoints[i];
                int distance = Math.Abs(waypoint.X - currentX) + Math.Abs(waypoint.Y - currentY);

                if (distance >= minDistance)
                {
                    targetIndex = i;
                    break;
                }

                // If we're getting close to the beginning, just use the first waypoint
                if (i == 0)
                {
                    targetIndex = i;
                }
            }
        }

        return waypoints[targetIndex];
    }



    static bool ClickWaypoint(Coordinate target, int pixelSize)
    {
        try
        {
            // Get current position
            pixelSize = 58;
            int currentX, currentY;
            lock (memoryLock)
            {
                currentX = posX;
                currentY = posY;
            }

            // Get client area size
            GetClientRect(targetWindow, out RECT rect);

            // Calculate the character center (base point)
            int baseX = (rect.Right - rect.Left) / 2 - 186;
            int baseY = (rect.Bottom - rect.Top) / 2 - 300;

            // Calculate movement vector
            int diffX = target.X - currentX;
            int diffY = target.Y - currentY;

            // Use the provided pixel size
            int targetX = baseX + (diffX * pixelSize);
            int targetY = baseY + (diffY * pixelSize);

            // Final combat check
            if (GetTargetId() != 0)
            {
                Console.WriteLine("[DEBUG] Combat detected, canceling movement");
                return false;
            }

            // Pack coordinates
            int lParam = (targetY << 16) | (targetX & 0xFFFF);

            // Send click
            PostMessage(targetWindow, 0x0200, IntPtr.Zero, (IntPtr)lParam);
            Thread.Sleep(50);
            PostMessage(targetWindow, WM_LBUTTONDOWN, (IntPtr)1, (IntPtr)lParam);
            Thread.Sleep(30);
            PostMessage(targetWindow, WM_LBUTTONUP, IntPtr.Zero, (IntPtr)lParam);
            Thread.Sleep(20);

            // Return mouse to center as requested
            int centerLParam = (baseY << 16) | (baseX & 0xFFFF);
            PostMessage(targetWindow, 0x0200, IntPtr.Zero, (IntPtr)centerLParam);

            Console.WriteLine($"[DEBUG] Clicked: X={diffX}, Y={diffY} (Screen: {targetX}, {targetY}, Pixel Size: {pixelSize})");
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[DEBUG] Click Error: {ex.Message}");
            return false;
        }
    }


    // Constants needed
    const byte VK_ESCAPE = 0x1B; // ESC key

  
    const int VK_F6 = 0x75;

    
    const int WM_LBUTTONDOWN = 0x0201;
    const int WM_LBUTTONUP = 0x0202;

    [StructLayout(LayoutKind.Sequential)]
    struct INPUT
    {
        public uint type;
        public InputUnion u;
    }

    [StructLayout(LayoutKind.Explicit)]
    struct InputUnion
    {
        [FieldOffset(0)] public MOUSEINPUT mi;
    }

    [StructLayout(LayoutKind.Sequential)]
    struct MOUSEINPUT
    {
        public int dx;
        public int dy;
        public uint mouseData;
        public uint dwFlags;
        public uint time;
        public IntPtr dwExtraInfo;
    }

    const int INPUT_MOUSE = 0;
    const uint MOUSEEVENTF_MOVE = 0x0001;
    const uint MOUSEEVENTF_ABSOLUTE = 0x8000;
    const uint MOUSEEVENTF_LEFTDOWN = 0x0002;
    const uint MOUSEEVENTF_LEFTUP = 0x0004;

    [DllImport("user32.dll")]
    static extern bool GetClientRect(IntPtr hWnd, out RECT lpRect);

    [DllImport("user32.dll")]
    static extern bool ClientToScreen(IntPtr hWnd, ref POINT lpPoint);

    [DllImport("user32.dll")]
    static extern uint SendInput(uint nInputs, INPUT[] pInputs, int cbSize);

    [StructLayout(LayoutKind.Sequential)]
    struct RECT
    {
        public int Left, Top, Right, Bottom;
    }

    [StructLayout(LayoutKind.Sequential)]
    struct POINT
    {
        public int X;
        public int Y;
    }

    [DllImport("user32.dll")]
    static extern int GetSystemMetrics(int nIndex);
    

    [DllImport("user32.dll")]
    static extern bool SetCursorPos(int X, int Y);

    static void CorpseEatFood(IntPtr hWnd)
    {
        // Define the specific coordinates to click
        (int x, int y)[] locations = new (int, int)[]
        {
        (1126, 325),
        (1165, 325),
        (1203, 325),
        (1236, 325)
        };

        // Get client area size to verify window is ready
        GetClientRect(hWnd, out RECT rect);

        // Ensure the window is large enough for these coordinates
        if (rect.Right < 1237 || rect.Bottom < 319)
        {
            Console.WriteLine($"Warning: Window size ({rect.Right}x{rect.Bottom}) may be too small for target coordinates");
        }

        foreach (var location in locations)
        {
            int x = location.x;
            int y = location.y;

            // Convert client coordinates to screen coordinates
            POINT screenPoint = new POINT { X = x, Y = y };
            ClientToScreen(hWnd, ref screenPoint);

            // Move mouse to the location
            Console.WriteLine($"Moving mouse to ({x}, {y}) - Screen: ({screenPoint.X}, {screenPoint.Y})");
            //SetCursorPos(screenPoint.X, screenPoint.Y);
            Thread.Sleep(1); // Pause so you can see the mouse movement

            // Right-click at the location
            Console.WriteLine($"Right-clicking at ({x}, {y})");
            VirtualRightClick(hWnd, x, y);
            Thread.Sleep(1); // Small delay between clicks

            // Optional: Check for target after each click
            int currentTargetId = GetTargetId();
            if (currentTargetId != 0)
            {
                Console.WriteLine($"Target acquired after clicking at ({x}, {y}). Target ID: {currentTargetId}");
                // You can choose to return here if you want to stop after finding a target
                // return;
            }
        }

        Console.WriteLine("Finished clicking all specified locations.");
    }

    static void ClickSpecificLocationsWithMouseMovement(IntPtr hWnd)
    {
        // Define the specific coordinates to click
        (int x, int y)[] locations = new (int, int)[]
        {
        (1129, 250),
        (1165, 250),
        (1203, 250),
        (1236, 250),
        (1126, 285),
        (1165, 285),
        (1203, 285),
        (1236, 285)
        };

        // Get client area size to verify window is ready
        GetClientRect(hWnd, out RECT rect);

        // Ensure the window is large enough for these coordinates
        if (rect.Right < 1237 || rect.Bottom < 319)
        {
            Console.WriteLine($"Warning: Window size ({rect.Right}x{rect.Bottom}) may be too small for target coordinates");
        }

        foreach (var location in locations)
        {
            int x = location.x;
            int y = location.y;

            // Convert client coordinates to screen coordinates
            POINT screenPoint = new POINT { X = x, Y = y };
            ClientToScreen(hWnd, ref screenPoint);

            // Move mouse to the location
            Console.WriteLine($"Moving mouse to ({x}, {y}) - Screen: ({screenPoint.X}, {screenPoint.Y})");
            //SetCursorPos(screenPoint.X, screenPoint.Y);
            Thread.Sleep(10); // Pause so you can see the mouse movement

            // Right-click at the location
            Console.WriteLine($"Right-clicking at ({x}, {y})");
            VirtualRightClick(hWnd, x, y);
            Thread.Sleep(10); // Small delay between clicks

            // Optional: Check for target after each click
            int currentTargetId = GetTargetId();
            if (currentTargetId != 0)
            {
                Console.WriteLine($"Target acquired after clicking at ({x}, {y}). Target ID: {currentTargetId}");
                // You can choose to return here if you want to stop after finding a target
                // return;
            }
        }

        Console.WriteLine("Finished clicking all specified locations.");
    }

    static void DragItemToCharacterCenter(IntPtr hWnd)
    {
        // Source coordinates (where to pick up the item)
        int sourceX = 1236;
        int sourceY = 285;

        // Get client rectangle to calculate character center
        GetClientRect(hWnd, out RECT rect);

        // Calculate the character center (destination)
        int centerX = (rect.Right - rect.Left) / 2 - 186;
        int centerY = (rect.Bottom - rect.Top) / 2 - 300;

        Console.WriteLine($"Moving to source position ({sourceX}, {sourceY})");

        // 1. Move mouse to source position
        IntPtr sourceLParam = MakeLParam(sourceX, sourceY);
        SendMessage(hWnd, WM_MOUSEMOVE, IntPtr.Zero, sourceLParam);
        Thread.Sleep(100); // Wait for cursor to move

        // 2. Press left mouse button down at source position
        SendMessage(hWnd, WM_LBUTTONDOWN, IntPtr.Zero, sourceLParam);
        Thread.Sleep(50);

        // 3. Move mouse to destination (character center) with left button held
        IntPtr centerLParam = MakeLParam(centerX, centerY);
        SendMessage(hWnd, WM_MOUSEMOVE, new IntPtr(MK_LBUTTON), centerLParam);
        Thread.Sleep(100);

        // 4. Release left mouse button at destination
        SendMessage(hWnd, WM_LBUTTONUP, IntPtr.Zero, centerLParam);
        Thread.Sleep(50);

        Console.WriteLine($"Completed drag from ({sourceX}, {sourceY}) to ({centerX}, {centerY})");
    }

    // Helper function for smooth dragging with intermediate positions
    static void SmoothDrag(IntPtr hWnd, int startX, int startY, int endX, int endY)
    {
        int steps = 5; // Number of intermediate positions
        for (int i = 1; i <= steps; i++)
        {
            int x = startX + (endX - startX) * i / (steps + 1);
            int y = startY + (endY - startY) * i / (steps + 1);

            IntPtr lParam = MakeLParam(x, y);
            SendMessage(hWnd, WM_MOUSEMOVE, new IntPtr(MK_LBUTTON), lParam);
            Thread.Sleep(10); // Small delay between steps
        }
    }

    const int MK_LBUTTON = 0x0001;

    // MakeLParam function remains the same
    static IntPtr MakeLParam(int x, int y)
    {
        return (IntPtr)((y << 16) | (x & 0xFFFF));
    }

    [DllImport("user32.dll")]
    static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

    // Helper function to send left mouse button down
    static void SendLeftMouseDown(IntPtr hWnd, int x, int y)
    {
        IntPtr lParam = MakeLParam(x, y);
        SendMessage(hWnd, WM_LBUTTONDOWN, IntPtr.Zero, lParam);
    }

    // Helper function to send left mouse button up
    static void SendLeftMouseUp(IntPtr hWnd, int x, int y)
    {
        IntPtr lParam = MakeLParam(x, y);
        SendMessage(hWnd, WM_LBUTTONUP, IntPtr.Zero, lParam);
    }

    static void ClickAroundCharacter(IntPtr hWnd)
    {
       // DragItemToCharacterCenter(hWnd);
        ClickSpecificLocationsWithMouseMovement(hWnd);
        double squareSize = 57; // Size of one tile

        // Directions: (X offset, Y offset) in tiles
        (int dx, int dy)[] directions = new (int, int)[]
        {
        (0, -1),  // Top
        (1, -1),  // Top-Right
        (1, 0),   // Right
        (1, 1),   // Bottom-Right
        (0, 1),   // Bottom
        (-1, 1),  // Bottom-Left
        (-1, 0),  // Left
        (-1, -1)  // Top-Left
        };

        // Get client area size
        GetClientRect(hWnd, out RECT rect);

        // Calculate the "character center" first (base point)
        int centerX = (rect.Right - rect.Left) / 2 - 186;
        int centerY = (rect.Bottom - rect.Top) / 2 - 300;

        foreach (var direction in directions)
        {
            int dx = direction.dx;
            int dy = direction.dy;

            int clickX = centerX + (int)(dx * squareSize);
            int clickY = centerY + (int)(dy * squareSize);

            VirtualRightClick(targetWindow, clickX, clickY);
            Thread.Sleep(1); // Small delay between clicks
            int currentTargetId = GetTargetId();
            if (currentTargetId != 0)
            {
                Console.WriteLine($"Target acquired after clicking at ({clickX}, {clickY}). Target ID: {currentTargetId}");
                return; // Exit early if something is targeted
            }
        }

        Console.WriteLine("Finished clicking all 8 tiles, no target found.");
        CorpseEatFood(targetWindow);
    }

    const int WM_MOUSEMOVE = 0x0200;
    const int WM_RBUTTONDOWN = 0x0204;
    const int WM_RBUTTONUP = 0x0205;
    const uint VK_LCONTROL = 0xA2; // Left Control key
    const uint VK_LMENU = 0xA4;    // Left Alt key
    const uint KEYEVENTF_KEYUP = 0x0002; // Key up flag

    [DllImport("user32.dll")]
    static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, uint dwExtraInfo);

    static void VirtualRightClick(IntPtr hWnd, int x, int y)
    {
        int lParam = (y << 16) | (x & 0xFFFF);

        PostMessage(hWnd, WM_MOUSEMOVE, IntPtr.Zero, (IntPtr)lParam);
        Thread.Sleep(1);

        PostMessage(hWnd, WM_RBUTTONDOWN, (IntPtr)1, (IntPtr)lParam);
        Thread.Sleep(1);

        PostMessage(hWnd, WM_RBUTTONUP, IntPtr.Zero, (IntPtr)lParam);
        Thread.Sleep(1);
    }

    static int GetTargetId()
    {
        lock (memoryLock)
        {
            return targetId;
        }
    }
}
