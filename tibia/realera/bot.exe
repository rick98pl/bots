using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.Json;
using System.Collections.Concurrent;
using System.Runtime.InteropServices;
class Program
{
    [DllImport("kernel32.dll")]
    static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int processId);
    [DllImport("user32.dll", SetLastError = true)]
    static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);
    [DllImport("kernel32.dll")]
    static extern bool ReadProcessMemory(
        IntPtr hProcess,
        IntPtr lpBaseAddress,
        byte[] buffer,
        int size,
        out int lpNumberOfBytesRead
    );
    [DllImport("user32.dll")]
    static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);
    [DllImport("user32.dll")]
    static extern int GetWindowText(IntPtr hWnd, System.Text.StringBuilder lpString, int nMaxCount);
    [DllImport("user32.dll")]
    static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);
    delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);
    const int PROCESS_WM_READ = 0x0010;
    const uint WM_KEYDOWN = 0x0100;
    const uint WM_KEYUP = 0x0101;
    const int VK_LEFT = 0x25;
    const int VK_UP = 0x26;
    const int VK_RIGHT = 0x27;
    const int VK_DOWN = 0x28;
    static class Keys
    {
        public static readonly Dictionary<string, int> KeyMap = new Dictionary<string, int>
        {
            { "F1", 0x70 },
            { "F2", 0x71 },
            { "F3", 0x72 },
            { "F4", 0x73 },
            { "F5", 0x74 },
            { "F6", 0x75 },
            { "F7", 0x76 },
            { "F8", 0x77 },
            { "F9", 0x78 },
            { "F10", 0x79 },
            { "F11", 0x7A },
            { "F12", 0x7B }
        };
        public static int GetKeyCode(string keyName) =>
            KeyMap.ContainsKey(keyName) ? KeyMap[keyName] : -1;
    }
    const int DEFAULT_HP_THRESHOLD = 50;
    const int DEFAULT_BEEP_HP_THRESHOLD = 30;
    const int DEFAULT_MANA_THRESHOLD = -1;
    const string DEFAULT_HP_KEY_NAME = "F1";
    const string DEFAULT_MANA_KEY_NAME = "F2";
    static int DEFAULT_HP_KEY => Keys.GetKeyCode(DEFAULT_HP_KEY_NAME);
    static int DEFAULT_MANA_KEY => Keys.GetKeyCode(DEFAULT_MANA_KEY_NAME);
    static IntPtr targetWindow = IntPtr.Zero;
    static DateTime lastHpActionTime = DateTime.MinValue;
    static DateTime lastManaActionTime = DateTime.MinValue;
    static Random random = new Random();
    static IntPtr xAddressOffset = (IntPtr)0x009435FC;
    static IntPtr yAddressOffset = (IntPtr)0x00943600;
    static IntPtr zAddressOffset = (IntPtr)0x00943604;
    static IntPtr targetIdOffset = (IntPtr)0x009432D4;
    static IntPtr followOffset = (IntPtr)0x00943380;
    static double curHP = 0,
        maxHP = 1,
        curMana = 0,
        maxMana = 1;
    static int posX = 0,
        posY = 0,
        posZ = 0,
        targetId = 0,
        follow = 0;
    static bool memoryReadActive = false;
    static bool programRunning = true;
    static bool autoPotionActive = true;
    static bool isRecording = false;
    static bool isPlaying = false;
    static bool shouldRestartMemoryThread = false;
    static ConcurrentDictionary<string, bool> threadFlags = new ConcurrentDictionary<
        string,
        bool
    >();
    static object memoryLock = new object();
    static List<Coordinate> recordedCoords = new List<Coordinate>();
    static string cordsFilePath = "cords.json";
    static CoordinateData loadedCoords = null;
    static Process selectedProcess = null;
    static IntPtr processHandle = IntPtr.Zero;
    static IntPtr moduleBase = IntPtr.Zero;
    struct Variable
    {
        public string Name;
        public IntPtr BaseAddress;
        public List<int> Offsets;
        public string Type;
    }
    class Coordinate
    {
        public int X { get; set; }
        public int Y { get; set; }
        public int Z { get; set; }
    }
    class CoordinateData
    {
        public List<Coordinate> cords { get; set; } = new List<Coordinate>();
    }
    static int currentCoordIndex = -1;
    static int totalCoords = 0;
    static Coordinate currentTarget = null;
    static bool debug = true;
    static int debugTime = 2;
    static void Main()
    {
        Console.WriteLine($"Default HP Key: {DEFAULT_HP_KEY_NAME}");
        Console.WriteLine($"Default Mana Key: {DEFAULT_MANA_KEY_NAME}");
        threadFlags["recording"] = false;
        threadFlags["playing"] = false;
        threadFlags["autopot"] = true;

        // Initialize the sound system
        InitializeSounds();

        if (!File.Exists(cordsFilePath))
        {
            SaveCoordinates();
        }

        // Rest of the Main method unchanged
        string processName = "RealeraDX";
        while (programRunning)
        {
            {
                while (selectedProcess == null)
                {
                    var processes = Process
                        .GetProcesses()
                        .Where(p => p.ProcessName == processName)
                        .ToArray();
                    if (processes.Length == 0)
                    {
                        Console.WriteLine($"Process '{processName}' not found.");
                        Sleep(500);
                        continue;
                    }
                    else if (processes.Length == 1)
                    {
                        selectedProcess = processes[0];
                        Console.WriteLine(
                            $"One process found: {selectedProcess.ProcessName} (ID: {selectedProcess.Id})"
                        );
                        Console.WriteLine($"Window Title: {selectedProcess.MainWindowTitle}");
                    }
                    else
                    {
                        Console.WriteLine($"Multiple processes found with name '{processName}':");
                        for (int i = 0; i < processes.Length; i++)
                        {
                            Console.WriteLine(
                                $"{i + 1}: ID={processes[i].Id}, Name={processes[i].ProcessName}, Window Title={processes[i].MainWindowTitle}, StartTime={(processes[i].StartTime)}"
                            );
                        }
                        Console.WriteLine(
                            "Enter the number of the process you want to select (1-9):"
                        );
                        string input = Console.ReadLine();
                        if (
                            int.TryParse(input, out int choice)
                            && choice >= 1
                            && choice <= processes.Length
                        )
                        {
                            selectedProcess = processes[choice - 1];
                            Console.WriteLine(
                                $"Selected process: {selectedProcess.ProcessName} (ID: {selectedProcess.Id})"
                            );
                            Console.WriteLine($"Window Title: {selectedProcess.MainWindowTitle}");
                        }
                        else
                        {
                            Console.WriteLine("Invalid selection. Please try again.");
                        }
                    }
                }
            }
            FindRealeraWindow(selectedProcess);
            processHandle = OpenProcess(PROCESS_WM_READ, false, selectedProcess.Id);
            moduleBase = selectedProcess.MainModule.BaseAddress;
            StartWorkerThreads();
            while (memoryReadActive && !shouldRestartMemoryThread)
            {
                if (Console.KeyAvailable)
                {
                    var key = Console.ReadKey(true).Key;
                    HandleUserInput(key);
                }
                Sleep(250);
            }
            if (shouldRestartMemoryThread)
            {
                shouldRestartMemoryThread = false;
                StopWorkerThreads();
                selectedProcess = null;
            }
        }
    }
    static void StartWorkerThreads()
    {
        memoryReadActive = true;
        Thread memoryThread = new Thread(MemoryReadingThread);
        memoryThread.IsBackground = true;
        memoryThread.Name = "MemoryReader";
        memoryThread.Start();
        Thread autoPotionThread = new Thread(AutoPotionThread);
        autoPotionThread.IsBackground = true;
        autoPotionThread.Name = "AutoPotion";
        autoPotionThread.Start();
        Console.WriteLine("Worker threads started successfully");
    }
    static void StopWorkerThreads()
    {
        memoryReadActive = false;
        threadFlags["recording"] = false;
        threadFlags["playing"] = false;
        StopPositionAlertSound(); // Stop any playing alert sounds
        Console.WriteLine("Worker threads stopping...");
        Sleep(1000);
    }
    static List<Variable> variables = new List<Variable>
    {
        new Variable
        {
            Name = "Current Mana",
            BaseAddress = (IntPtr)0x009432D0,
            Offsets = new List<int> { 1240 },
            Type = "Double"
        },
        new Variable
        {
            Name = "Current HP",
            BaseAddress = (IntPtr)0x009432D0,
            Offsets = new List<int> { 1184 },
            Type = "Double"
        },
        new Variable
        {
            Name = "Max Mana",
            BaseAddress = (IntPtr)0x009432D0,
            Offsets = new List<int> { 1248 },
            Type = "Double"
        },
        new Variable
        {
            Name = "Max HP",
            BaseAddress = (IntPtr)0x009432D0,
            Offsets = new List<int> { 1192 },
            Type = "Double"
        }
    };
    static void MemoryReadingThread()
    {
        Console.WriteLine("Memory reading thread started");
        while (memoryReadActive)
        {
            try
            {
                if (selectedProcess.HasExited)
                {
                    shouldRestartMemoryThread = true;
                    break;
                }
                foreach (var variable in variables)
                {
                    try
                    {
                        IntPtr address = IntPtr.Add(moduleBase, (int)variable.BaseAddress);
                        byte[] buffer;
                        if (variable.Offsets.Count > 0)
                        {
                            buffer = new byte[4];
                            if (
                                !ReadProcessMemory(
                                    processHandle,
                                    address,
                                    buffer,
                                    buffer.Length,
                                    out _
                                )
                            )
                                continue;
                            address = (IntPtr)BitConverter.ToInt32(buffer, 0);
                            address = IntPtr.Add(address, variable.Offsets[0]);
                        }
                        buffer = variable.Type == "Double" ? new byte[8] : new byte[4];
                        if (
                            !ReadProcessMemory(processHandle, address, buffer, buffer.Length, out _)
                        )
                            continue;
                        double value =
                            variable.Type == "Double"
                                ? BitConverter.ToDouble(buffer, 0)
                                : BitConverter.ToInt32(buffer, 0);
                        lock (memoryLock)
                        {
                            if (variable.Name.Contains("HP") && !variable.Name.Contains("Max"))
                                curHP = value;
                            if (variable.Name.Contains("Mana") && !variable.Name.Contains("Max"))
                                curMana = value;
                            if (variable.Name.Contains("Max HP"))
                                maxHP = value;
                            if (variable.Name.Contains("Max Mana"))
                                maxMana = value;
                        }
                    }
                    catch { }
                }
                lock (memoryLock)
                {
                    posX = ReadInt32(processHandle, moduleBase, xAddressOffset);
                    posY = ReadInt32(processHandle, moduleBase, yAddressOffset);
                    posZ = ReadInt32(processHandle, moduleBase, zAddressOffset);
                    targetId = ReadInt32(processHandle, moduleBase, targetIdOffset);
                    follow = ReadInt32(processHandle, moduleBase, followOffset);
                    if (threadFlags["recording"])
                    {
                        RecordCoordinate(posX, posY, posZ);
                    }
                }

                // Check position distance if we have loaded coordinates
                if (loadedCoords != null && loadedCoords.cords.Count > 0 && threadFlags["playing"])
                {
                    CheckPositionDistance(loadedCoords.cords);
                }

                Sleep(1);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Memory reading error: {ex.Message}");
                shouldRestartMemoryThread = true;
                break;
            }
        }
        Console.WriteLine("Memory reading thread exited");
    }

    static void AutoPotionThread()
    {
        Console.WriteLine("Auto-potion thread started");
        while (memoryReadActive)
        {
            try
            {
                if (threadFlags["autopot"] && targetWindow != IntPtr.Zero)
                {
                    var now = DateTime.Now;
                    var thresholdms = 1000;
                    double hpPercent,
                        manaPercent;
                    lock (memoryLock)
                    {
                        hpPercent = (curHP / maxHP) * 100;
                        manaPercent = (curMana / maxMana) * 100;
                    }
                    if (hpPercent == 0)
                    {
                        Sleep(1);
                        continue;
                    }

                    if (hpPercent <= DEFAULT_BEEP_HP_THRESHOLD)
                    {
                        StartPositionAlertSound();
                    }

                    if (hpPercent <= DEFAULT_HP_THRESHOLD)
                    {
                        if ((now - lastHpActionTime).TotalMilliseconds >= thresholdms)
                        {
                            Console.WriteLine(
                                $"⚠ HP below threshold ({DEFAULT_HP_THRESHOLD}%), current HP: {curHP}/{maxHP} ({hpPercent:F1}%), sending {DEFAULT_HP_KEY_NAME}"
                            );
                            SendKeyPress(DEFAULT_HP_KEY);
                            lastHpActionTime = now.AddMilliseconds(random.Next(0, 100));
                        }
                    }
                    else
                    {
                        //StopPositionAlertSound();
                    }
                    if (manaPercent <= DEFAULT_MANA_THRESHOLD)
                    {
                        if ((now - lastManaActionTime).TotalMilliseconds >= thresholdms)
                        {
                            Console.WriteLine(
                                $"⚠ Mana below threshold ({DEFAULT_MANA_THRESHOLD}%), sending {DEFAULT_MANA_KEY_NAME}"
                            );
                            SendKeyPress(DEFAULT_MANA_KEY);
                            lastManaActionTime = now.AddMilliseconds(random.Next(0, 100));
                        }
                    }
                }
                Sleep(100);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Auto-potion error: {ex.Message}");
                Sleep(1000);
            }
        }
        Console.WriteLine("Auto-potion thread exited");
    }
    static void DisplayStats()
    {
        Console.Clear();
        double hpPercent;
        double manaPercent;
        int currentX,
            currentY,
            currentZ;
        lock (memoryLock)
        {
            hpPercent = (curHP / maxHP) * 100;
            manaPercent = (curMana / maxMana) * 100;
            currentX = posX;
            currentY = posY;
            currentZ = posZ;
        }
        Console.WriteLine("RealeraDX - Live Stats:\n");
        Console.WriteLine("{0,-20} {1,15}", "Metric", "Value");
        Console.WriteLine(new string('-', 40));
        Console.WriteLine("{0,-20} {1,15:F0}", "Current HP", curHP);
        Console.WriteLine("{0,-20} {1,15:F0}", "Max HP", maxHP);
        Console.WriteLine("{0,-20} {1,15:F1}%", "HP %", hpPercent);
        Console.WriteLine("{0,-20} {1,15:F0}", "Current Mana", curMana);
        Console.WriteLine("{0,-20} {1,15:F0}", "Max Mana", maxMana);
        Console.WriteLine("{0,-20} {1,15:F1}%", "Mana %", manaPercent);
        Console.WriteLine("{0,-20} {1,15:F0}", "targetId", targetId);
        Console.WriteLine("{0,-20} {1,15:F0}", "follow", follow);
        Console.WriteLine(new string('-', 40));
        Console.WriteLine($"Position: X={currentX}, Y={currentY}, Z={currentZ}");
        if (threadFlags["recording"])
        {
            Console.WriteLine("🔴 Recording coordinates...");
            Console.WriteLine($"Coordinates recorded: {recordedCoords.Count}");
        }
        if (threadFlags["playing"] && currentTarget != null)
        {
            Console.WriteLine("\n▶️ PLAYING PATH:");
            Console.WriteLine(new string('-', 40));
            Console.WriteLine(
                $"Progress: {currentCoordIndex + 1}/{totalCoords} ({(((float)(currentCoordIndex + 1) / totalCoords) * 100):F1}%)"
            );
            Console.WriteLine($"Current: X={currentX}, Y={currentY}, Z={currentZ}");
            Console.WriteLine(
                $"Target:  X={currentTarget.X}, Y={currentTarget.Y}, Z={currentTarget.Z}"
            );
            int distanceX = Math.Abs(currentTarget.X - currentX);
            int distanceY = Math.Abs(currentTarget.Y - currentY);
            Console.WriteLine($"Distance: {distanceX + distanceY} steps");
            int barLength = 20;
            int progress = (int)Math.Round(
                (double)(currentCoordIndex + 1) / totalCoords * barLength
            );
            Console.Write("[");
            for (int i = 0; i < barLength; i++)
            {
                Console.Write(i < progress ? "█" : " ");
            }
            Console.WriteLine($"] {(((float)(currentCoordIndex + 1) / totalCoords) * 100):F1}%");
        }
        Console.WriteLine("\nActive Features:");
        Console.WriteLine($"Auto-Potions: {(threadFlags["autopot"] ? "✅ ON" : "❌ OFF")} (A)");
        Console.WriteLine($"Recording: {(threadFlags["recording"] ? "✅ ON" : "❌ OFF")} (R)");
        Console.WriteLine($"Playback: {(threadFlags["playing"] ? "✅ ON" : "❌ OFF")} (P)");
        Console.WriteLine("\nCommands:");
        Console.WriteLine("R - Start/Stop Recording");
        Console.WriteLine("P - Start/Stop Path Playback");
        Console.WriteLine("A - Toggle Auto-Potions");
        Console.WriteLine("Q - Quit");
    }
    static void HandleUserInput(ConsoleKey key)
    {
        switch (key)
        {
            case ConsoleKey.R:
                if (!threadFlags["recording"] && !threadFlags["playing"])
                {
                    Console.Write("Start recording coordinates? (y/n): ");
                    string confirm = Console.ReadLine();
                    if (confirm.ToLower() == "y")
                    {
                        threadFlags["recording"] = true;
                        recordedCoords.Clear();
                        Console.WriteLine("Started recording coordinates...");
                    }
                }
                else if (threadFlags["recording"])
                {
                    threadFlags["recording"] = false;
                    SaveCoordinates();
                    Console.WriteLine("Stopped recording and saved coordinates.");
                }
                break;
            case ConsoleKey.P:
                if (!threadFlags["playing"] && !threadFlags["recording"])
                {
                    if (File.Exists(cordsFilePath))
                    {
                        threadFlags["playing"] = true;
                        StartPathPlayback();
                    }
                    else
                    {
                        Console.WriteLine("cords.json not found!");
                        Sleep(1000);
                    }
                }
                else if (threadFlags["playing"])
                {
                    threadFlags["playing"] = false;
                    Console.WriteLine("Path playback stopped.");
                }
                break;
            case ConsoleKey.A:
                threadFlags["autopot"] = !threadFlags["autopot"];
                Console.WriteLine(
                    $"Auto-potions {(threadFlags["autopot"] ? "enabled" : "disabled")}"
                );
                break;
            case ConsoleKey.S: // Add a key to manually stop position alert sound
                StopPositionAlertSound();
                Console.WriteLine("Position alert sound stopped manually.");
                break;
            case ConsoleKey.Q:
                programRunning = false;
                memoryReadActive = false;
                threadFlags["recording"] = false;
                threadFlags["playing"] = false;
                threadFlags["autopot"] = false;
                // Make sure to stop any playing sounds
                StopPositionAlertSound();
                break;
        }
    }
    static void StartPathPlayback()
    {
        Thread playThread = new Thread(
            () =>
            {
                try
                {
                    PlayCoordinates();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Path playback error: {ex.Message}");
                }
                finally
                {
                    threadFlags["playing"] = false;
                }
            }
        );
        playThread.IsBackground = true;
        playThread.Name = "PathPlayer";
        playThread.Start();
    }
    static int ReadInt32(IntPtr handle, IntPtr moduleBase, IntPtr offset)
    {
        IntPtr address = IntPtr.Add(moduleBase, (int)offset);
        byte[] buffer = new byte[4];
        if (ReadProcessMemory(handle, address, buffer, buffer.Length, out _))
            return BitConverter.ToInt32(buffer, 0);
        return 0;
    }
    static void SendKeyPress(int key)
    {
        PostMessage(targetWindow, WM_KEYDOWN, (IntPtr)key, IntPtr.Zero);
        Sleep(random.Next(10, 25));
        PostMessage(targetWindow, WM_KEYUP, (IntPtr)key, IntPtr.Zero);
    }
    static void FindRealeraWindow(Process process)
    {
        EnumWindows(
            (hWnd, lParam) =>
            {
                uint windowProcessId;
                GetWindowThreadProcessId(hWnd, out windowProcessId);
                if (windowProcessId == (uint)process.Id)
                {
                    StringBuilder sb = new StringBuilder(256);
                    GetWindowText(hWnd, sb, sb.Capacity);
                    if (sb.ToString().Contains("Realera 8.0"))
                    {
                        targetWindow = hWnd;
                        return false;
                    }
                }
                return true;
            },
            IntPtr.Zero
        );
    }
    static void SaveCoordinates()
    {
        CoordinateData data = new CoordinateData { cords = recordedCoords };
        string json = JsonSerializer.Serialize(
            data,
            new JsonSerializerOptions { WriteIndented = true }
        );
        File.WriteAllText(cordsFilePath, json);
    }
    static void RecordCoordinate(int x, int y, int z)
    {
        if (
            recordedCoords.Count == 0
            || recordedCoords.Last().X != x
            || recordedCoords.Last().Y != y
            || recordedCoords.Last().Z != z
        )
        {
            recordedCoords.Add(new Coordinate { X = x, Y = y, Z = z });
        }
    }
    private static void MoveCharacterTowardsWaypoint(
        int currentX,
        int currentY,
        int waypointX,
        int waypointY
    )
    {
        int diffX = waypointX - currentX;
        int diffY = waypointY - currentY;
        bool tryXFirst = Math.Abs(diffX) > Math.Abs(diffY);
        if (tryXFirst)
        {
            if (diffX > 0)
            {
                Console.WriteLine("[DEBUG] Moving EAST with arrow key");
                SendKeyPress(VK_RIGHT);
            }
            else if (diffX < 0)
            {
                Console.WriteLine("[DEBUG] Moving WEST with arrow key");
                SendKeyPress(VK_LEFT);
            }
            Sleep(150);
            if (diffY > 0)
            {
                Console.WriteLine("[DEBUG] Moving SOUTH with arrow key");
                SendKeyPress(VK_DOWN);
            }
            else if (diffY < 0)
            {
                Console.WriteLine("[DEBUG] Moving NORTH with arrow key");
                SendKeyPress(VK_UP);
            }
        }
        else
        {
            if (diffY > 0)
            {
                Console.WriteLine("[DEBUG] Moving SOUTH with arrow key");
                SendKeyPress(VK_DOWN);
            }
            else if (diffY < 0)
            {
                Console.WriteLine("[DEBUG] Moving NORTH with arrow key");
                SendKeyPress(VK_UP);
            }
            Sleep(150);
            if (diffX > 0)
            {
                Console.WriteLine("[DEBUG] Moving EAST with arrow key");
                SendKeyPress(VK_RIGHT);
            }
            else if (diffX < 0)
            {
                Console.WriteLine("[DEBUG] Moving WEST with arrow key");
                SendKeyPress(VK_LEFT);
            }
        }
    }
    static bool shouldClickAround = true;
    private static int previousTargetId = 0;
    static void PlayCoordinates()
    {
        Console.WriteLine("Path playback starting...");
        string json = File.ReadAllText(cordsFilePath);
        loadedCoords = JsonSerializer.Deserialize<CoordinateData>(json);
        if (loadedCoords == null || loadedCoords.cords.Count == 0)
        {
            Console.WriteLine("No coordinates found in cords.json!");
            threadFlags["playing"] = false;
            return;
        }
        List<Coordinate> waypoints = loadedCoords.cords;
        totalCoords = waypoints.Count;
        HashSet<int> blacklistedTargets = new HashSet<int>();
        bool isReversed = false;
        Console.WriteLine($"Loaded {totalCoords} coordinates from cords.json");
        int currentX,
            currentY,
            currentZ;
        lock (memoryLock)
        {
            currentX = posX;
            currentY = posY;
            currentZ = posZ;
        }
        currentCoordIndex = FindClosestWaypointIndex(waypoints, currentX, currentY, currentZ);
        Console.WriteLine($"[DEBUG] Starting at closest waypoint: index {currentCoordIndex}");
        while (threadFlags["playing"])
        {
            try
            {
                int currentTargetId;
                lock (memoryLock)
                {
                    currentX = posX;
                    currentY = posY;
                    currentZ = posZ;
                    currentTargetId = targetId;
                }
                if (previousTargetId != 0 && currentTargetId == 0)
                {
                    ToggleRing(targetWindow, false);
                    Sleep(1);

                    Console.WriteLine("[DEBUG] Fight finished, calling ClickAroundCharacter");
                    if (shouldClickAround)
                    {
                        shouldClickAround = false;
                        Console.WriteLine("[DEBUG] shouldClickAround set false");
                        ClickAroundCharacter(targetWindow);
                    }
                    Sleep(1);
                    lock (memoryLock)
                    {
                        currentTargetId = targetId;
                    }
                }
                previousTargetId = currentTargetId;
                lock (memoryLock)
                {
                    currentTargetId = targetId;
                }
                if (currentTargetId != 0)
                {

                    ToggleRing(targetWindow, true);
                    Sleep(1);
                    var (monsterX, monsterY, monsterZ, monsterName) = GetTargetMonsterInfo();
                    Sleep(1);
                    if (blacklistedTargets.Contains(currentTargetId))
                    {

                        Console.WriteLine(
                            $"[DEBUG] Skipping blacklisted target ID: {currentTargetId}"
                        );
                        SendKeyPress(VK_ESCAPE);
                        Sleep(1);
                        continue;
                    }
                    if (
                        !string.IsNullOrEmpty(monsterName)
                        && blacklistedMonsterNames.Contains(monsterName)
                    )
                    {

                        Console.WriteLine(
                            $"[DEBUG] Skipping blacklisted monster: {monsterName}"
                        );
                        SendKeyPress(VK_ESCAPE);
                        Sleep(1);
                        continue;
                    }
                    Sleep(100);
                    lock (memoryLock)
                    {
                        currentTargetId = targetId;
                    }
                    if (!string.IsNullOrEmpty(monsterName)){
                        shouldClickAround = true;
                    }
                        lock (memoryLock)
                        {
                            currentX = posX;
                            currentY = posY;
                            currentZ = posZ;
                        }
                    continue;
                }
                lock (memoryLock)
                {
                    currentTargetId = targetId;
                }
                if (currentTargetId == 0)
                {

                    Console.WriteLine("[DEBUG] No target, pressing F6 to search");
                    SendKeyPress(VK_F6);
                    Sleep(256); //CRUCIAL YOU CANT SPAM F6 because targetId is getting weird!!! even if no mnoster
                }
                
                lock (memoryLock)
                {
                    currentTargetId = targetId;
                }
                if (currentTargetId != 0)
                {

                    Console.WriteLine($"[DEBUG] Found target: {currentTargetId}");
                    continue;
                }
                Console.WriteLine("[DEBUG] No target found, proceeding with movement");
                Sleep(1);
                Coordinate nextWaypoint = FindNextWaypoint(
                    ref waypoints,
                    currentX,
                    currentY,
                    currentZ,
                    ref currentCoordIndex
                );
                currentTarget = nextWaypoint;
                Console.WriteLine(
                    $"[DEBUG] Moving to waypoint: X={nextWaypoint.X}, Y={nextWaypoint.Y}, Z={nextWaypoint.Z}"
                );
                int distanceX = Math.Abs(nextWaypoint.X - currentX);
                int distanceY = Math.Abs(nextWaypoint.Y - currentY);
                int totalDistance = distanceX + distanceY;
                if (distanceX > 5 || distanceY > 5)
                {

                    Console.WriteLine(
                        $"[DEBUG] Waypoint too far to click: X={nextWaypoint.X}, Y={nextWaypoint.Y}, Z={nextWaypoint.Z}"
                    );

                    Console.WriteLine(
                        $"[DEBUG] Current position: X={currentX}, Y={currentY}, Z={currentZ}"
                    );

                    Console.WriteLine($"[DEBUG] Distance: X={distanceX}, Y={distanceY}");
                    int maxMoves = 5;
                    int movesMade = 0;
                    while ((distanceX > 5 || distanceY > 5) && movesMade < maxMoves)
                    {
                        MoveCharacterTowardsWaypoint(
                            currentX,
                            currentY,
                            nextWaypoint.X,
                            nextWaypoint.Y
                        );
                        Sleep(150);
                        lock (memoryLock)
                        {
                            currentX = posX;
                            currentY = posY;
                            currentZ = posZ;
                        }
                        distanceX = Math.Abs(nextWaypoint.X - currentX);
                        distanceY = Math.Abs(nextWaypoint.Y - currentY);

                        Console.WriteLine(
                            $"[DEBUG] After move #{movesMade + 1}, new position: X={currentX}, Y={currentY}"
                        );

                        Console.WriteLine(
                            $"[DEBUG] New distance: X={distanceX}, Y={distanceY}"
                        );
                        movesMade++;
                        if (distanceX <= 5 && distanceY <= 5)
                        {

                            Console.WriteLine("[DEBUG] Now within clickable range");
                            break;
                        }
                        if (movesMade % 2 == 0)
                        {

                            Console.WriteLine("[DEBUG] Switching movement priority");
                        }
                    }
                    if (distanceX > 5 || distanceY > 5)
                    {

                        Console.WriteLine(
                            "[DEBUG] Still too far after arrow movement, finding a new waypoint"
                        );
                        currentCoordIndex = FindClosestWaypointIndex(
                            waypoints,
                            currentX,
                            currentY,
                            currentZ
                        );
                        continue;
                    }
                }
                Console.WriteLine(
                    $"[DEBUG] Clicking waypoint: X={nextWaypoint.X}, Y={nextWaypoint.Y}, Z={nextWaypoint.Z}"
                );
                bool clickSuccess = ClickWaypoint(nextWaypoint);
                Sleep(900);
                if (clickSuccess)
                {
                    int followStatus;
                    lock (memoryLock)
                    {
                        followStatus = follow;
                        currentTargetId = targetId;
                    }
                    if (currentTargetId == 0)
                    {
                        SendKeyPress(VK_F6);
                        Sleep(256); //CRUCIAL YOU CANT SPAM F6 because targetId is getting weird!!! even if no mnoster
                        lock (memoryLock)
                        {
                            currentTargetId = targetId;
                        }
                        if (currentTargetId != 0)
                        {

                            Console.WriteLine(
                                "[DEBUG] Target found after movement, switching to combat"
                            );
                            continue;
                        }
                    }
                }
                Sleep(1);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in path playback: {ex.Message}");
                Sleep(1);
            }
        }
        Console.WriteLine("Path playback ended");
    }
    static int FindClosestWaypointIndex(
        List<Coordinate> waypoints,
        int currentX,
        int currentY,
        int currentZ
    )
    {
        int closestIndex = 0;
        int minDistance = int.MaxValue;
        for (int i = 0; i < waypoints.Count; i++)
        {
            var waypoint = waypoints[i];
            int distance = Math.Abs(waypoint.X - currentX) + Math.Abs(waypoint.Y - currentY);
            if (distance < minDistance)
            {
                minDistance = distance;
                closestIndex = i;
            }
        }
        return closestIndex;
    }
    static Coordinate FindNextWaypoint(
        ref List<Coordinate> waypoints,
        int currentX,
        int currentY,
        int currentZ,
        ref int currentIndex
    )
    {
        Console.WriteLine("\n=== FIND NEXT WAYPOINT DEBUG ===");
        Console.WriteLine($"Current position: X={currentX}, Y={currentY}, Z={currentZ}");
        Console.WriteLine($"Current index: {currentIndex}");
        Console.WriteLine($"Total waypoints: {waypoints.Count}");
        if (waypoints.Count == 0)
        {
            Console.WriteLine("ERROR: Empty waypoints list");
            return new Coordinate { X = currentX, Y = currentY, Z = currentZ };
        }
        if (currentIndex < 0 || currentIndex >= waypoints.Count)
        {
            Console.WriteLine($"ERROR: Current index {currentIndex} out of bounds");
            currentIndex = Math.Max(0, Math.Min(waypoints.Count - 1, currentIndex));
            Console.WriteLine($"Corrected to index {currentIndex}");
        }
        if (currentIndex == waypoints.Count - 1)
        {
            Console.WriteLine("At last waypoint, checking if we should reverse list...");
            int distanceToFirst =
                Math.Abs(waypoints[0].X - currentX) + Math.Abs(waypoints[0].Y - currentY);
            Console.WriteLine($"Distance to first waypoint: {distanceToFirst} steps");
            if (distanceToFirst > 12)
            {
                Console.WriteLine("Distance > 12, REVERSING THE LIST NOW");
                waypoints.Reverse();
                currentIndex = 0;
                Console.WriteLine("List reversed, now at index 0");
            }
        }
        int maxSearchCount = 10;
        int maxAllowedX = 5;
        int maxAllowedY = 5;
        int bestIndex = -1;
        double maxDistance = 0;
        Console.WriteLine("Starting waypoint search...");
        int startIndex,
            endIndex;
        startIndex = currentIndex + 1;
        endIndex = Math.Min(waypoints.Count - 1, currentIndex + maxSearchCount);
        Console.WriteLine($"Searching forward from index {startIndex} to {endIndex}");
        for (int index = startIndex; index <= endIndex; index++)
        {
            if (index < 0 || index >= waypoints.Count)
                continue;
            Coordinate waypoint = waypoints[index];
            int deltaX = Math.Abs(waypoint.X - currentX);
            int deltaY = Math.Abs(waypoint.Y - currentY);
            Console.WriteLine(
                $"  Checking waypoint[{index}]: X={waypoint.X}, Y={waypoint.Y}, deltaX={deltaX}, deltaY={deltaY}"
            );
            if (deltaX <= maxAllowedX && deltaY <= maxAllowedY)
            {
                double distance = Math.Sqrt(deltaX * deltaX + deltaY * deltaY);
                Console.WriteLine($"  Distance: {distance:F2} (within limits)");
                if (distance > maxDistance)
                {
                    maxDistance = distance;
                    bestIndex = index;
                    Console.WriteLine($"  New best! Distance={distance:F2}, Index={bestIndex}");
                }
            }
            else
            {
                Console.WriteLine($"  Skipped: Outside distance limits");
            }
        }
        if (bestIndex == -1)
        {
            Console.WriteLine("No valid waypoint found ahead. Choosing adjacent waypoint...");
            if (currentIndex < waypoints.Count - 1)
            {
                bestIndex = currentIndex + 1;
                Console.WriteLine($"Moving to next waypoint (index {bestIndex})");
            }
            else
            {
                bestIndex = currentIndex;
                Console.WriteLine(
                    "At last waypoint, no valid waypoint ahead. Staying at current position."
                );
            }
        }
        bestIndex = Math.Max(0, Math.Min(waypoints.Count - 1, bestIndex));
        currentIndex = bestIndex;
        Coordinate result = waypoints[bestIndex];
        Console.WriteLine(
            $"Final choice: waypoint[{bestIndex}]: X={result.X}, Y={result.Y}, Z={result.Z}"
        );
        Console.WriteLine("=== END FIND NEXT WAYPOINT DEBUG ===\n");
        return result;
    }
    static bool ClickWaypoint(Coordinate target)
    {
        try
        {
            int pixelSize = 58;
            int currentX,
                currentY;
            lock (memoryLock)
            {
                currentX = posX;
                currentY = posY;
            }
            GetClientRect(targetWindow, out RECT rect);
            int baseX = (rect.Right - rect.Left) / 2 - 186;
            int baseY = (rect.Bottom - rect.Top) / 2 - 300;
            int diffX = target.X - currentX;
            int diffY = target.Y - currentY;
            int targetX = baseX + (diffX * pixelSize);
            int targetY = baseY + (diffY * pixelSize);
            if (GetTargetId() != 0)
            {
                Console.WriteLine("[DEBUG] Combat detected, canceling movement");
                return false;
            }
            int lParam = (targetY << 16) | (targetX & 0xFFFF);
            SendKeyPress(VK_ESCAPE);
            Sleep(1);
            PostMessage(targetWindow, 0x0200, IntPtr.Zero, (IntPtr)lParam);
            Sleep(1);
            PostMessage(targetWindow, WM_LBUTTONDOWN, (IntPtr)1, (IntPtr)lParam);
            Sleep(1);
            PostMessage(targetWindow, WM_LBUTTONUP, IntPtr.Zero, (IntPtr)lParam);
            Sleep(1);
            int centerLParam = (baseY << 16) | (baseX & 0xFFFF);
            PostMessage(targetWindow, 0x0200, IntPtr.Zero, (IntPtr)centerLParam);
            Console.WriteLine(
                $"[DEBUG] Clicked: X={diffX}, Y={diffY} (Screen: {targetX}, {targetY}, Pixel Size: {pixelSize})"
            );
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[DEBUG] Click Error: {ex.Message}");
            return false;
        }
    }
    const byte VK_ESCAPE = 0x1B;
    const int VK_F6 = 0x75;
    const int WM_LBUTTONDOWN = 0x0201;
    const int WM_LBUTTONUP = 0x0202;
    [StructLayout(LayoutKind.Sequential)]
    struct INPUT
    {
        public uint type;
        public InputUnion u;
    }
    [StructLayout(LayoutKind.Explicit)]
    struct InputUnion
    {
        [FieldOffset(0)]
        public MOUSEINPUT mi;
    }
    [StructLayout(LayoutKind.Sequential)]
    struct MOUSEINPUT
    {
        public int dx;
        public int dy;
        public uint mouseData;
        public uint dwFlags;
        public uint time;
        public IntPtr dwExtraInfo;
    }
    const int INPUT_MOUSE = 0;
    const uint MOUSEEVENTF_MOVE = 0x0001;
    const uint MOUSEEVENTF_ABSOLUTE = 0x8000;
    const uint MOUSEEVENTF_LEFTDOWN = 0x0002;
    const uint MOUSEEVENTF_LEFTUP = 0x0004;
    [DllImport("user32.dll")]
    static extern bool GetClientRect(IntPtr hWnd, out RECT lpRect);
    [DllImport("user32.dll")]
    static extern bool ClientToScreen(IntPtr hWnd, ref POINT lpPoint);
    [DllImport("user32.dll")]
    static extern uint SendInput(uint nInputs, INPUT[] pInputs, int cbSize);
    [StructLayout(LayoutKind.Sequential)]
    struct RECT
    {
        public int Left,
            Top,
            Right,
            Bottom;
    }
    [StructLayout(LayoutKind.Sequential)]
    struct POINT
    {
        public int X;
        public int Y;
    }
    [DllImport("user32.dll")]
    static extern int GetSystemMetrics(int nIndex);
    [DllImport("user32.dll")]
    static extern bool SetCursorPos(int X, int Y);
    static void CloseCorspe(IntPtr hWnd)
    {
        (int x, int y)[] locations = new (int, int)[] { (1262, 320) };
        GetClientRect(hWnd, out RECT rect);
        if (rect.Right < 1237 || rect.Bottom < 319)
        {
            Console.WriteLine(
                $"Warning: Window size ({rect.Right}x{rect.Bottom}) may be too small for target coordinates"
            );
        }
        foreach (var location in locations)
        {
            int x = location.x;
            int y = location.y;
            POINT screenPoint = new POINT { X = x, Y = y };
            ClientToScreen(hWnd, ref screenPoint);
            Sleep(1);
            VirtualLeftClick(hWnd, x, y);
            Sleep(1);
        }
    }
    static void CorpseEatFood(IntPtr hWnd)
    {
        (int x, int y)[] locations = new (int, int)[]
        {
            (1126, 325),
            (1165, 325),
            (1203, 325),
            (1236, 325),
            (1126, 340),
            (1165, 340),
            (1203, 340),
            (1236, 340)
        };
        GetClientRect(hWnd, out RECT rect);
        if (rect.Right < 1237 || rect.Bottom < 319)
        {
            Console.WriteLine(
                $"Warning: Window size ({rect.Right}x{rect.Bottom}) may be too small for target coordinates"
            );
        }
        foreach (var location in locations)
        {
            int x = location.x;
            int y = location.y;
            POINT screenPoint = new POINT { X = x, Y = y };
            ClientToScreen(hWnd, ref screenPoint);
            Sleep(1);
            VirtualRightClick(hWnd, x, y);
            Sleep(1);
        }
    }
    static void ClickSecondSlotInBackpack(IntPtr hWnd)
    {
        (int x, int y)[] locations = new (int, int)[] { (1165, 250) };
        GetClientRect(hWnd, out RECT rect);
        if (rect.Right < 1237 || rect.Bottom < 319)
        {
            Console.WriteLine(
                $"Warning: Window size ({rect.Right}x{rect.Bottom}) may be too small for target coordinates"
            );
        }
        foreach (var location in locations)
        {
            int x = location.x;
            int y = location.y;
            POINT screenPoint = new POINT { X = x, Y = y };
            ClientToScreen(hWnd, ref screenPoint);
            Sleep(1);
            //SetCursorPos(screenPoint.X, screenPoint.Y);
            VirtualRightClick(hWnd, x, y);
            Sleep(1);
            int currentTargetId = GetTargetId();
            if (currentTargetId != 0)
            {
                Console.WriteLine(
                    $"Target acquired after clicking at ({x}, {y}). Target ID: {currentTargetId}"
                );
            }
        }
    }
    static void DragItemToCharacterCenter(IntPtr hWnd)
    {
        int sourceX = 1236;
        int sourceY = 285;
        GetClientRect(hWnd, out RECT rect);
        int centerX = (rect.Right - rect.Left) / 2 - 186;
        int centerY = (rect.Bottom - rect.Top) / 2 - 300;
        Console.WriteLine($"Moving to source position ({sourceX}, {sourceY})");
        IntPtr sourceLParam = MakeLParam(sourceX, sourceY);
        SendMessage(hWnd, WM_MOUSEMOVE, IntPtr.Zero, sourceLParam);
        Sleep(1);
        SendMessage(hWnd, WM_LBUTTONDOWN, IntPtr.Zero, sourceLParam);
        Sleep(1);
        IntPtr centerLParam = MakeLParam(centerX, centerY);
        SendMessage(hWnd, WM_MOUSEMOVE, new IntPtr(MK_LBUTTON), centerLParam);
        Sleep(1);
        SendMessage(hWnd, WM_LBUTTONUP, IntPtr.Zero, centerLParam);
        Sleep(1);
        Console.WriteLine($"Completed drag from ({sourceX}, {sourceY}) to ({centerX}, {centerY})");
    }
    const int MK_LBUTTON = 0x0001;
    static IntPtr MakeLParam(int x, int y)
    {
        return (IntPtr)((y << 16) | (x & 0xFFFF));
    }
    [DllImport("user32.dll")]
    static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);
    static void ClickAroundCharacter(IntPtr hWnd)
    {
        ClickSecondSlotInBackpack(hWnd);
        double squareSize = 57;
        (int dx, int dy)[] directions = new (int, int)[]
        {
            (0, -1),
            (1, -1),
            (1, 0),
            (1, 1),
            (0, 1),
            (-1, 1),
            (-1, 0),
            (-1, -1)
        };
        GetClientRect(hWnd, out RECT rect);
        int centerX = (rect.Right - rect.Left) / 2 - 186;
        int centerY = (rect.Bottom - rect.Top) / 2 - 300;
        foreach (var direction in directions)
        {
            int dx = direction.dx;
            int dy = direction.dy;
            int clickX = centerX + (int)(dx * squareSize);
            int clickY = centerY + (int)(dy * squareSize);
            VirtualRightClick(targetWindow, clickX, clickY);
            Sleep(1);
            int currentTargetId = GetTargetId();
            if (currentTargetId != 0)
            {
                Console.WriteLine(
                    $"Target acquired after clicking at ({clickX}, {clickY}). Target ID: {currentTargetId}"
                );
            }
        }
        CorpseEatFood(targetWindow);
        CloseCorspe(targetWindow);
    }
    const int WM_MOUSEMOVE = 0x0200;
    const int WM_RBUTTONDOWN = 0x0204;
    const int WM_RBUTTONUP = 0x0205;
    const uint VK_LCONTROL = 0xA2;
    const uint VK_LMENU = 0xA4;
    const uint KEYEVENTF_KEYUP = 0x0002;
    [DllImport("user32.dll")]
    static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, uint dwExtraInfo);
    static void VirtualRightClick(IntPtr hWnd, int x, int y)
    {
        int lParam = (y << 16) | (x & 0xFFFF);
        PostMessage(hWnd, WM_MOUSEMOVE, IntPtr.Zero, (IntPtr)lParam);
        Sleep(1);
        PostMessage(hWnd, WM_RBUTTONDOWN, (IntPtr)1, (IntPtr)lParam);
        Sleep(1);
        PostMessage(hWnd, WM_RBUTTONUP, IntPtr.Zero, (IntPtr)lParam);
        Sleep(1);
    }
    static void VirtualLeftClick(IntPtr hWnd, int x, int y)
    {
        int lParam = (y << 16) | (x & 0xFFFF);
        PostMessage(hWnd, WM_MOUSEMOVE, IntPtr.Zero, (IntPtr)lParam);
        Sleep(1);
        PostMessage(hWnd, WM_LBUTTONDOWN, (IntPtr)1, (IntPtr)lParam);
        Sleep(1);
        PostMessage(hWnd, WM_LBUTTONUP, IntPtr.Zero, (IntPtr)lParam);
        Sleep(1);
    }
    static int GetTargetId()
    {
        lock (memoryLock)
        {
            return targetId;
        }
    }
    static (int monsterX, int monsterY, int monsterZ) GetTargetMonsterCoordinates()
    {
        int targetId = 0;
        int monsterX = 0,
            monsterY = 0,
            monsterZ = 0;
        lock (memoryLock)
        {
            targetId = ReadInt32(processHandle, moduleBase, targetIdOffset);
            if (targetId != 0)
            {
                IntPtr monsterInstancePtr = IntPtr.Zero;
                byte[] buffer = new byte[4];
                if (
                    ReadProcessMemory(
                        processHandle,
                        IntPtr.Add(moduleBase, (int)targetIdOffset),
                        buffer,
                        buffer.Length,
                        out _
                    )
                )
                {
                    monsterInstancePtr = (IntPtr)BitConverter.ToInt32(buffer, 0);
                    if (
                        ReadProcessMemory(
                            processHandle,
                            IntPtr.Add(monsterInstancePtr, 0x000C),
                            buffer,
                            buffer.Length,
                            out _
                        )
                    )
                    {
                        monsterX = BitConverter.ToInt32(buffer, 0);
                    }
                    if (
                        ReadProcessMemory(
                            processHandle,
                            IntPtr.Add(monsterInstancePtr, 0x0010),
                            buffer,
                            buffer.Length,
                            out _
                        )
                    )
                    {
                        monsterY = BitConverter.ToInt32(buffer, 0);
                    }
                    if (
                        ReadProcessMemory(
                            processHandle,
                            IntPtr.Add(monsterInstancePtr, 0x0014),
                            buffer,
                            buffer.Length,
                            out _
                        )
                    )
                    {
                        monsterZ = BitConverter.ToInt32(buffer, 0);
                    }
                }
            }
        }
        return (monsterX, monsterY, monsterZ);
    }
    static string ReadStringFromMemory(IntPtr handle, IntPtr address, int maxLength = 128)
    {
        try
        {
            byte[] buffer = new byte[maxLength];
            int bytesRead;
            if (!ReadProcessMemory(handle, address, buffer, buffer.Length, out bytesRead))
            {
                return string.Empty;
            }
            int nullTerminatorPos = 0;
            while (nullTerminatorPos < buffer.Length && buffer[nullTerminatorPos] != 0)
            {
                nullTerminatorPos++;
            }
            if (nullTerminatorPos > 0)
            {
                return Encoding.ASCII.GetString(buffer, 0, nullTerminatorPos);
            }
            return string.Empty;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading string from memory: {ex.Message}");
            return string.Empty;
        }
    }
    static List<string> blacklistedMonsterNames = new List<string> { "Rat", "Rabbit", "Snake" };
    static (int monsterX, int monsterY, int monsterZ, string monsterName) GetTargetMonsterInfo()
    {
        int targetId = 0;
        int monsterX = 0,
            monsterY = 0,
            monsterZ = 0;
        string monsterName = "";
        lock (memoryLock)
        {
            targetId = ReadInt32(processHandle, moduleBase, targetIdOffset);
            if (targetId != 0)
            {
                IntPtr monsterInstancePtr = IntPtr.Zero;
                byte[] buffer = new byte[4];
                if (
                    ReadProcessMemory(
                        processHandle,
                        IntPtr.Add(moduleBase, (int)targetIdOffset),
                        buffer,
                        buffer.Length,
                        out _
                    )
                )
                {
                    monsterInstancePtr = (IntPtr)BitConverter.ToInt32(buffer, 0);
                    if (
                        ReadProcessMemory(
                            processHandle,
                            IntPtr.Add(monsterInstancePtr, 0x000C),
                            buffer,
                            buffer.Length,
                            out _
                        )
                    )
                    {
                        monsterX = BitConverter.ToInt32(buffer, 0);
                    }
                    if (
                        ReadProcessMemory(
                            processHandle,
                            IntPtr.Add(monsterInstancePtr, 0x0010),
                            buffer,
                            buffer.Length,
                            out _
                        )
                    )
                    {
                        monsterY = BitConverter.ToInt32(buffer, 0);
                    }
                    if (
                        ReadProcessMemory(
                            processHandle,
                            IntPtr.Add(monsterInstancePtr, 0x0014),
                            buffer,
                            buffer.Length,
                            out _
                        )
                    )
                    {
                        monsterZ = BitConverter.ToInt32(buffer, 0);
                    }
                    monsterName = ReadStringFromMemory(
                        processHandle,
                        IntPtr.Add(monsterInstancePtr, 0x0030)
                    );
                    if(targetId == 0)
                    {
                        monsterName = "";
                    }
                }
            }
        }
        return (monsterX, monsterY, monsterZ, monsterName);
    }
    static int lastRingEquippedTargetId = 0;
    static bool isRingCurrentlyEquipped = false;
    static List<string> blacklistedRingMonsters = new List<string> { "Poison Spider", };
    static void ToggleRing(IntPtr hWnd, bool equip)
    {
        try
        {
            int currentTargetId;
            lock (memoryLock)
            {
                currentTargetId = targetId;
            }
            if (equip && isRingCurrentlyEquipped && currentTargetId == lastRingEquippedTargetId)
            {
                return;
            }
            if (equip && currentTargetId != 0)
            {
                var (monsterX, monsterY, monsterZ, monsterName) = GetTargetMonsterInfo();
                if (
                    !string.IsNullOrEmpty(monsterName)
                    && blacklistedRingMonsters.Contains(monsterName)
                )
                {

                    Console.WriteLine(
                        $"[DEBUG] Monster '{monsterName}' is blacklisted for ring usage"
                    );
                    return;
                }
                int playerX,
                    playerY,
                    playerZ;
                lock (memoryLock)
                {
                    playerX = posX;
                    playerY = posY;
                    playerZ = posZ;
                }
                double distance = Math.Sqrt(
                    Math.Pow(monsterX - playerX, 2) + Math.Pow(monsterY - playerY, 2)
                );
                if (distance > 2.5)
                {
                    return;
                }
            }
            int inventoryX = 940;
            int inventoryY = 65;
            int equipmentX = 1115;
            int equipmentY = 150;
            int sourceX = equip ? inventoryX : equipmentX;
            int sourceY = equip ? inventoryY : equipmentY;
            int destX = equip ? equipmentX : inventoryX;
            int destY = equip ? equipmentY : inventoryY;
            Console.WriteLine($"[DEBUG] {(equip ? "Equipping" : "De-equipping")} ring");
            IntPtr sourceLParam = MakeLParam(sourceX, sourceY);
            PostMessage(hWnd, WM_MOUSEMOVE, IntPtr.Zero, sourceLParam);
            Sleep(1);
            PostMessage(hWnd, WM_LBUTTONDOWN, IntPtr.Zero, sourceLParam);
            Sleep(1);
            IntPtr destLParam = MakeLParam(destX, destY);
            PostMessage(hWnd, WM_MOUSEMOVE, new IntPtr(MK_LBUTTON), destLParam);
            Sleep(1);
            PostMessage(hWnd, WM_LBUTTONUP, IntPtr.Zero, destLParam);
            Sleep(1);
            if (equip)
            {
                lastRingEquippedTargetId = currentTargetId;
                isRingCurrentlyEquipped = true;
                Console.WriteLine(
                    $"[DEBUG] Successfully equipped ring for target {currentTargetId}"
                );
            }
            else
            {
                isRingCurrentlyEquipped = false;
                Console.WriteLine($"[DEBUG] Successfully de-equipped ring");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[DEBUG] Error toggling ring: {ex.Message}");
        }
    }

    static void Sleep(int miliseconds)
    {
        Thread.Sleep(miliseconds);
    }

    static CancellationTokenSource positionAlertCts = null;
    static readonly object soundLock = new object();
    static DateTime lastPositionAlertTime = DateTime.MinValue;
    static readonly int POSITION_ALERT_COOLDOWN_SEC = 60; // One minute cooldown for position alerts
    static readonly int MAX_DISTANCE_SQMS = 50; // Maximum allowed distance in sqms

    // Add these Win32 API declarations for playing sounds
    [DllImport("kernel32.dll")]
    static extern bool Beep(int frequency, int duration);

    // Alternative sound method if Beep doesn't work well enough
    [DllImport("winmm.dll", SetLastError = true, CallingConvention = CallingConvention.Winapi)]
    static extern bool PlaySound(string pszSound, IntPtr hmod, uint fdwSound);

    // Sound flags for PlaySound API
    const uint SND_FILENAME = 0x00020000;
    const uint SND_ASYNC = 0x0001;
    const uint SND_NODEFAULT = 0x0002;

    // Sound frequencies and durations
    const int CLICK_COMPLETED_FREQ = 800;
    const int CLICK_COMPLETED_DURATION = 200;
    const int POSITION_ALERT_FREQ = 1200;
    const int POSITION_ALERT_DURATION = 500;

    // Add this method to the Program class to check if sound files exist
    static void InitializeSounds()
    {
        try
        {
            // Create sound for click around completion
            string clickCompletedSoundPath = Path.Combine(
                AppDomain.CurrentDomain.BaseDirectory,
                "click_completed.wav"
            );

            // Create sound for position alert
            string positionAlertSoundPath = Path.Combine(
                AppDomain.CurrentDomain.BaseDirectory,
                "position_alert.wav"
            );

            // Check if sound files exist
            if (!File.Exists(clickCompletedSoundPath))
            {
                Console.WriteLine("Warning: click_completed.wav not found. Using system beep instead.");
            }
            else
            {
                Console.WriteLine("Found click_completed.wav");
            }

            if (!File.Exists(positionAlertSoundPath))
            {
                Console.WriteLine("Warning: position_alert.wav not found. Using system beep instead.");
            }
            else
            {
                Console.WriteLine("Found position_alert.wav");
            }

            Console.WriteLine("Sound system initialized successfully.");

            // Test beep to verify sound capability
            //Beep(800, 200);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing sounds: {ex.Message}");
        }
    }

    // Add this method to play the click completed sound
    static void PlayClickCompletedSound()
    {
        try
        {
            string clickCompletedSoundPath = Path.Combine(
                AppDomain.CurrentDomain.BaseDirectory,
                "click_completed.wav"
            );

            if (File.Exists(clickCompletedSoundPath))
            {
                // Play WAV file if it exists
                bool success = PlaySound(clickCompletedSoundPath, IntPtr.Zero, SND_FILENAME | SND_ASYNC);
                if (success)
                {
                    Console.WriteLine("[SOUND] Click around completed sound played from file.");
                    return;
                }
            }

            // Fall back to Beep if file doesn't exist or PlaySound failed
            Beep(CLICK_COMPLETED_FREQ, CLICK_COMPLETED_DURATION);
            Console.WriteLine("[SOUND] Click around completed beep played.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error playing click completed sound: {ex.Message}");
            try
            {
                // Last resort fallback
                Console.Beep(CLICK_COMPLETED_FREQ, CLICK_COMPLETED_DURATION);
            }
            catch
            {
                Console.WriteLine("All sound methods failed!");
            }
        }
    }

    // Add this method to start playing the position alert sound repeatedly
    static void StartPositionAlertSound(int maxDurationSeconds = 60)
    {
        lock (soundLock)
        {
            // Check if we're already playing or if we're in cooldown period
            if (positionAlertCts != null ||
                (DateTime.Now - lastPositionAlertTime).TotalSeconds < POSITION_ALERT_COOLDOWN_SEC)
            {
                return;
            }

            Console.WriteLine($"[SOUND] Starting position alert sound (max {maxDurationSeconds} seconds).");
            lastPositionAlertTime = DateTime.Now;

            // Create a new cancellation token source
            positionAlertCts = new CancellationTokenSource();
            var token = positionAlertCts.Token;

            // Get the path to position alert sound file
            string positionAlertSoundPath = Path.Combine(
                AppDomain.CurrentDomain.BaseDirectory,
                "position_alert.wav"
            );
            bool useWavFile = File.Exists(positionAlertSoundPath);

            // Start a task to play the sound repeatedly
            Task.Run(() =>
            {
                try
                {
                    DateTime startTime = DateTime.Now;
                    while (!token.IsCancellationRequested &&
                           (DateTime.Now - startTime).TotalSeconds < maxDurationSeconds)
                    {
                        try
                        {
                            if (useWavFile)
                            {
                                // Try to play the WAV file
                                bool success = PlaySound(positionAlertSoundPath, IntPtr.Zero, SND_FILENAME | SND_ASYNC);
                                if (!success)
                                {
                                    // Fall back to Beep if PlaySound failed
                                    Beep(POSITION_ALERT_FREQ, POSITION_ALERT_DURATION);
                                }
                            }
                            else
                            {
                                // Use Beep if no WAV file
                                Beep(POSITION_ALERT_FREQ, POSITION_ALERT_DURATION);
                            }
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"Error playing position alert sound: {ex.Message}");
                            try
                            {
                                // Last resort fallback
                                Console.Beep(POSITION_ALERT_FREQ, POSITION_ALERT_DURATION);
                            }
                            catch
                            {
                                Console.WriteLine("All sound methods failed!");
                            }
                        }

                        // Wait before playing again
                        Thread.Sleep(1500);
                    }

                    Console.WriteLine("[SOUND] Position alert sound stopped.");
                }
                catch (TaskCanceledException)
                {
                    Console.WriteLine("[SOUND] Position alert sound cancelled.");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error in position alert sound loop: {ex.Message}");
                }
                finally
                {
                    lock (soundLock)
                    {
                        positionAlertCts = null;
                    }
                }
            }, token);
        }
    }

    // Add this method to stop the position alert sound
    static void StopPositionAlertSound()
    {
        lock (soundLock)
        {
            if (positionAlertCts != null)
            {
                positionAlertCts.Cancel();
                positionAlertCts = null;
                Console.WriteLine("[SOUND] Position alert sound cancelled.");
            }
        }
    }

    // Add this method to check if position is too far from any waypoint
    static void CheckPositionDistance(List<Coordinate> waypoints)
    {
        if (waypoints == null || waypoints.Count == 0)
        {
            return;
        }

        int currentX, currentY, currentZ;
        lock (memoryLock)
        {
            currentX = posX;
            currentY = posY;
            currentZ = posZ;
        }

        // Find the closest waypoint
        int minDistance = int.MaxValue;
        foreach (var waypoint in waypoints)
        {
            int distance = Math.Abs(waypoint.X - currentX) + Math.Abs(waypoint.Y - currentY);
            if (distance < minDistance)
            {
                minDistance = distance;
            }
        }

        // If the closest waypoint is too far, start playing the alert
        if (minDistance > MAX_DISTANCE_SQMS)
        {
            Console.WriteLine($"[WARNING] Position too far from any waypoint! Distance: {minDistance} sqm");
            StartPositionAlertSound();
        }
        else
        {
            //StopPositionAlertSound();
        }
    }

}
